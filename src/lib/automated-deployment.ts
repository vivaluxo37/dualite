import { supabase } from './supabase'; import { GeneratedContent } from './content-generation'; export interface GeneratedPage { brokerId: string; brokerName: string; contentType: string; content: string; title: string; description: string; seoOptimization: any; qualityAssurance: any; metadata: any; } export interface DeploymentConfig { outputDir: string; templateDir: string; generateRoutes: boolean; updateSitemap: boolean; deployToProduction: boolean; } export interface DeploymentResult { success: boolean; deployedPages: string[]; errors: string[]; deploymentTime: number; sitemapUpdated: boolean; routesGenerated: boolean; } export interface ReactPageTemplate { name: string; template: string; requiredFields: string[]; outputPath: string; } export interface PageComponent { name: string; path: string; component: string; metadata: { title: string; description: string; keywords: string[]; category: string; brokerId?: string; }; dependencies: string[]; } class AutomatedDeploymentService { private config: DeploymentConfig; constructor(config: DeploymentConfig) { this.config = config; } async deployPages(pages: GeneratedPage[]): Promise<DeploymentResult> { const startTime = Date.now(); const deployedPages: string[] = []; const errors: string[] = []; let sitemapUpdated = false; let routesGenerated = false; try { console.log(`Starting deployment of ${pages.length} pages...`); // Generate React components for each page for (const page of pages) { try { const component = await this.generateReactComponent(page); await this.saveComponentToFile(component); deployedPages.push(component.path); console.log(`✅ Deployed: ${component.name}`); } catch (error) { const errorMessage = `Failed to deploy ${page.brokerName}: ${error}`; errors.push(errorMessage); console.error(errorMessage); } } // Generate routes if configured if (this.config.generateRoutes && deployedPages.length > 0) { try { await this.generateRoutes(deployedPages); routesGenerated = true; console.log('✅ Routes generated successfully'); } catch (error) { const errorMessage = `Failed to generate routes: ${error}`; errors.push(errorMessage); console.error(errorMessage); } } // Update sitemap if configured if (this.config.updateSitemap && deployedPages.length > 0) { try { await this.updateSitemap(deployedPages); sitemapUpdated = true; console.log('✅ Sitemap updated successfully'); } catch (error) { const errorMessage = `Failed to update sitemap: ${error}`; errors.push(errorMessage); console.error(errorMessage); } } // Update deployment status in database await this.updateDeploymentStatus(pages, deployedPages, errors); const deploymentTime = Date.now() - startTime; return { success: errors.length === 0, deployedPages, errors, deploymentTime, sitemapUpdated, routesGenerated }; } catch (error) { const errorMessage = `Deployment failed: ${error}`; errors.push(errorMessage); console.error(errorMessage); return { success: false, deployedPages, errors, deploymentTime: Date.now() - startTime, sitemapUpdated, routesGenerated }; } } private async generateReactComponent(page: GeneratedPage): Promise<PageComponent> { const template = this.getPageTemplate(page.contentType); // Replace template variables with actual content let component = template.template .replace('{{TITLE}}', page.seoOptimization.metaTags.title) .replace('{{DESCRIPTION}}', page.seoOptimization.metaTags.description) .replace('{{KEYWORDS}}', page.seoOptimization.metaTags.keywords.join(', ')) .replace('{{CONTENT}}', this.formatContentForReact(page.content)) .replace('{{BROKER_NAME}}', page.brokerName) .replace('{{BROKER_ID}}', page.brokerId) .replace('{{STRUCTURED_DATA}}', JSON.stringify(page.seoOptimization.structuredData)) .replace('{{INTERNAL_LINKS}}', this.generateInternalLinks(page.seoOptimization.internalLinks)) .replace('{{HEADERS}}', this.generateHeaderStructure(page.seoOptimization.headerStructure)); // Add required imports const imports = this.generateImports(page); component = imports + '\n\n' + component; return { name: this.generateComponentName(page.brokerName, page.contentType), path: this.generateComponentPath(page.brokerName, page.contentType), component, metadata: { title: page.seoOptimization.metaTags.title, description: page.seoOptimization.metaTags.description, keywords: page.seoOptimization.metaTags.keywords, category: page.contentType, brokerId: page.brokerId }, dependencies: this.getDependencies(page.contentType) }; } private getPageTemplate(contentType: string): ReactPageTemplate { const templates: Record<string, ReactPageTemplate> = { 'broker-profile': { name: 'BrokerProfile', template: ` import React from 'react'; import { BrokerSEO } from '../components/seo/BrokerSEO'; import { StructuredData } from '../components/seo/StructuredData'; const {{COMPONENT_NAME}} = () => { return ( <> <BrokerSEO title="{{TITLE}}" description="{{DESCRIPTION}}" keywords="{{KEYWORDS}}" structuredData={{{STRUCTURED_DATA}}} /> <div className="min-h-screen bg-gradient-to-br from-slate-50 to-blue-50"> <div className="container mx-auto px-4 py-8"> <article className="max-w-4xl mx-auto"> <header className="mb-8"> <h1 className="text-4xl font-bold text-slate-900 mb-4"> {{BROKER_NAME}} Review </h1> <p className="text-lg text-slate-600"> {{DESCRIPTION}} </p> </header> <div className="prose prose-lg max-w-none"> {{HEADERS}} {{CONTENT}} </div> {{INTERNAL_LINKS}} </article> </div> </div> </> ); }; export default {{COMPONENT_NAME}}; `, requiredFields: ['title', 'description', 'content', 'brokerName'], outputPath: 'src/pages/brokers/[brokerId].tsx' }, 'comparison': { name: 'BrokerComparison', template: ` import React from 'react'; import { BrokerSEO } from '../components/seo/BrokerSEO'; import { StructuredData } from '../components/seo/StructuredData'; const {{COMPONENT_NAME}} = () => { return ( <> <BrokerSEO title="{{TITLE}}" description="{{DESCRIPTION}}" keywords="{{KEYWORDS}}" structuredData={{{STRUCTURED_DATA}}} /> <div className="min-h-screen bg-gradient-to-br from-slate-50 to-blue-50"> <div className="container mx-auto px-4 py-8"> <article className="max-w-6xl mx-auto"> <header className="mb-8"> <h1 className="text-4xl font-bold text-slate-900 mb-4"> {{TITLE}} </h1> <p className="text-lg text-slate-600"> {{DESCRIPTION}} </p> </header> <div className="prose prose-lg max-w-none"> {{HEADERS}} {{CONTENT}} </div> {{INTERNAL_LINKS}} </article> </div> </div> </> ); }; export default {{COMPONENT_NAME}}; `, requiredFields: ['title', 'description', 'content'], outputPath: 'src/pages/comparison/[comparisonId].tsx' }, 'guide': { name: 'TradingGuide', template: ` import React from 'react'; import { BrokerSEO } from '../components/seo/BrokerSEO'; import { StructuredData } from '../components/seo/StructuredData'; const {{COMPONENT_NAME}} = () => { return ( <> <BrokerSEO title="{{TITLE}}" description="{{DESCRIPTION}}" keywords="{{KEYWORDS}}" structuredData={{{STRUCTURED_DATA}}} /> <div className="min-h-screen bg-gradient-to-br from-slate-50 to-blue-50"> <div className="container mx-auto px-4 py-8"> <article className="max-w-4xl mx-auto"> <header className="mb-8"> <h1 className="text-4xl font-bold text-slate-900 mb-4"> {{TITLE}} </h1> <p className="text-lg text-slate-600"> {{DESCRIPTION}} </p> </header> <div className="prose prose-lg max-w-none"> {{HEADERS}} {{CONTENT}} </div> {{INTERNAL_LINKS}} </article> </div> </div> </> ); }; export default {{COMPONENT_NAME}}; `, requiredFields: ['title', 'description', 'content'], outputPath: 'src/pages/guides/[guideId].tsx' } }; return templates[contentType] || templates['broker-profile']; } private formatContentForReact(content: string): string { // Convert markdown-style content to JSX-compatible format return content .replace(/^### (.*$)/gm, '<h3 className="text-2xl font-semibold text-slate-800 mt-8 mb-4">$1</h3>') .replace(/^## (.*$)/gm, '<h2 className="text-3xl font-semibold text-slate-800 mt-8 mb-6">$1</h2>') .replace(/^# (.*$)/gm, '<h1 className="text-4xl font-bold text-slate-900 mt-8 mb-6">$1</h1>') .replace(/\*\*(.*?)\*\*/g, '<strong className="font-semibold text-slate-900">$1</strong>') .replace(/\*(.*?)\*/g, '<em className="italic text-slate-700">$1</em>') .replace(/\n\n/g, '</p><p className="mb-4 text-slate-700 leading-relaxed">') .replace(/^(?!<[h|p])/gm, '<p className="mb-4 text-slate-700 leading-relaxed">') .replace(/<p className="mb-4 text-slate-700 leading-relaxed"><\/p>/g, ''); } private generateInternalLinks(links: string[]): string { if (links.length === 0) return ''; return ` <nav className="mt-12 p-6 bg-blue-50 rounded-lg"> <h3 className="text-lg font-semibold text-slate-900 mb-4">Related Articles</h3> <ul className="space-y-2"> ${links.map(link => ` <li> <a href="${link}" className="text-blue-600 hover:text-blue-800 transition-colors"> ${this.formatLinkText(link)} </a> </li> `).join('')} </ul> </nav> `; } private generateHeaderStructure(headers: Array<{ level: number; text: string }>): string { return headers.map(header => { const className = header.level === 1 ? 'text-4xl font-bold text-slate-900 mt-8 mb-6' : header.level === 2 ? 'text-3xl font-semibold text-slate-800 mt-8 mb-6' : header.level === 3 ? 'text-2xl font-semibold text-slate-800 mt-8 mb-4' : 'text-xl font-semibold text-slate-700 mt-6 mb-3'; return `<h${header.level} className="${className}">${header.text}</h${header.level}>`; }).join('\n'); } private generateImports(_page: GeneratedPage): string { const baseImports = `import React from 'react';`; const seoImports = `import { BrokerSEO } from '../components/seo/BrokerSEO';`; const structuredDataImports = `import { StructuredData } from '../components/seo/StructuredData';`; return `${baseImports}\n${seoImports}\n${structuredDataImports}`; } private generateComponentName(brokerName: string, contentType: string): string { const cleanName = brokerName.replace(/[^a-zA-Z0-9]/g, ''); const cleanType = contentType.replace(/[^a-zA-Z0-9]/g, ''); return `${cleanName}${cleanType.charAt(0).toUpperCase() + cleanType.slice(1)}`; } private generateComponentPath(brokerName: string, _contentType: string): string { const cleanName = brokerName.toLowerCase().replace(/[^a-zA-Z0-9]/g, '-'); return `src/pages/brokers/${cleanName}.tsx`; } private getDependencies(_contentType: string): string[] { const baseDeps = ['react']; const seoDeps = ['../components/seo/BrokerSEO', '../components/seo/StructuredData']; return [...baseDeps, ...seoDeps]; } private formatLinkText(link: string): string { return link .replace(/https?:\/\//, '') .replace(/\/$/, '') .split('/') .pop() || link; } private async saveComponentToFile(component: PageComponent): Promise<void> { // In a real implementation, this would write to the file system // For now, we'll simulate it by storing in the database const { data, error } = await supabase .from('deployed_pages') .insert([ { name: component.name, path: component.path, component: component.component, metadata: component.metadata, dependencies: component.dependencies, deployed_at: new Date().toISOString() } ]); if (error) { throw new Error(`Failed to save component: ${error.message}`); } } private async generateRoutes(deployedPages: string[]): Promise<void> { const routeTemplate = ` import React from 'react'; import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'; import Layout from '../components/Layout'; ${deployedPages.map(page => { const componentName = page.split('/').pop()?.replace('.tsx', '') || 'Unknown'; return `import ${componentName} from '../${page.replace('.tsx', '')}';`; }).join('\n')} const AppRoutes = () => { return ( <Router> <Layout> <Routes> ${deployedPages.map(page => { const componentName = page.split('/').pop()?.replace('.tsx', '') || 'Unknown'; const routePath = page.replace('src/pages', '').replace('.tsx', '').replace(/\[([^\]]+)\]/g, ':$1'); return `<Route path="${routePath}" element={<${componentName} />} />`; }).join('\n ')} </Routes> </Layout> </Router> ); }; export default AppRoutes; `; // Save routes to database const { error } = await supabase .from('deployed_routes') .insert([ { routes: routeTemplate, pages: deployedPages, generated_at: new Date().toISOString() } ]); if (error) { throw new Error(`Failed to generate routes: ${error.message}`); } } private async updateSitemap(deployedPages: string[]): Promise<void> { const baseUrl = 'https://brokeranalysis.com'; const sitemapEntries = deployedPages.map(page => { const url = page.replace('src/pages', '').replace('.tsx', '').replace(/\[([^\]]+)\]/g, ':$1'); return ` <url> <loc>${baseUrl}${url}</loc> <lastmod>${new Date().toISOString().split('T')[0]}</lastmod> <changefreq>weekly</changefreq> <priority>0.8</priority> </url>`; }).join(''); const sitemap = `<?xml version="1.0" encoding="UTF-8"?> <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"> ${sitemapEntries} </urlset>`; // Save sitemap to database const { error } = await supabase .from('deployed_sitemaps') .insert([ { sitemap, pages: deployedPages, generated_at: new Date().toISOString() } ]); if (error) { throw new Error(`Failed to update sitemap: ${error.message}`); } } private async updateDeploymentStatus( pages: GeneratedPage[], deployedPages: string[], errors: string[] ): Promise<void> { const deploymentData = pages.map(page => ({ broker_id: page.brokerId, content_type: page.contentType, deployed: deployedPages.some(p => p.includes(page.brokerName.toLowerCase())), deployed_at: new Date().toISOString(), deployment_errors: errors.filter(e => e.includes(page.brokerName)) })); const { error } = await supabase .from('deployment_status') .insert(deploymentData); if (error) { console.error('Failed to update deployment status:', error); } } async getDeploymentHistory(limit: number = 50): Promise<any[]> { const { data, error } = await supabase .from('deployment_status') .select('*') .order('deployed_at', { ascending: false }) .limit(limit); if (error) { throw new Error(`Failed to get deployment history: ${error.message}`); } return data || []; } async rollbackDeployment(deploymentId: string): Promise<boolean> { try { // Get deployment details const { data: deployment, error } = await supabase .from('deployment_status') .select('*') .eq('id', deploymentId) .single(); if (error || !deployment) { throw new Error('Deployment not found'); } // Remove deployed pages await supabase .from('deployed_pages') .delete() .eq('broker_id', deployment.broker_id); // Update deployment status await supabase .from('deployment_status') .update({ deployed: false, rolled_back_at: new Date().toISOString() }) .eq('id', deploymentId); return true; } catch (error) { console.error('Rollback failed:', error); return false; } } } export default AutomatedDeploymentService;