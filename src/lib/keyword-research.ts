// This service uses the WebSearch MCP tool and Supabase MCP tools for keyword research export interface KeywordResearch { id?: string; broker_id: string; keyword: string; search_volume?: number; difficulty?: number; intent: 'informational' | 'commercial' | 'transactional' | 'navigational'; topic_cluster: string; created_at: string; updated_at: string; } export interface CompetitorKeyword { keyword: string; url: string; position: number; volume: number; difficulty: number; } export interface KeywordCluster { main_keyword: string; cluster_name: string; keywords: string[]; search_intent: string; content_type: 'guide' | 'review' | 'comparison' | 'tutorial' | 'news'; priority: 'high' | 'medium' | 'low'; } export class KeywordResearchAgent { private supabaseProjectId: string; constructor(supabaseProjectId: string) { this.supabaseProjectId = supabaseProjectId; } private async performWebSearch(query: string, limit: number = 5): Promise<any[]> { try { // This would use the WebSearch MCP tool // For now, we'll return mock data to test the structure console.log(`Performing web search for: "${query}"`); // Mock search results - in real implementation, this would call WebSearch MCP return [ { title: `${query} - Forex Broker Review`, url: `https://example.com/${query.replace(/\s+/g, '-')}`, snippet: `Comprehensive review and analysis of ${query}. Find the best trading conditions and features.` } ]; } catch (error) { console.error(`Web search failed for query "${query}":`, error); return []; } } async performComprehensiveKeywordResearch(brokerName: string, brokerId: string): Promise<KeywordResearch[]> { try { console.log(`Starting comprehensive keyword research for ${brokerName}`); // Step 1: Generate extensive seed keywords const seedKeywords = await this.generateComprehensiveSeedKeywords(brokerName); // Step 2: Use WebSearch to expand keywords with real data const expandedKeywords = await this.expandKeywordsWithRealSearch(seedKeywords, brokerName); // Step 3: Perform competitor keyword analysis const competitorKeywords = await this.performDeepCompetitorAnalysis(brokerName); // Step 4: Research question-based keywords (People Also Ask) const questionKeywords = await this.researchQuestionKeywords(brokerName); // Step 5: Generate long-tail variations const longTailKeywords = await this.generateLongTailVariations(seedKeywords, brokerName); // Step 6: Research location-specific keywords const locationKeywords = await this.researchLocationKeywords(brokerName); // Step 7: Research trading-style specific keywords const tradingStyleKeywords = await this.researchTradingStyleKeywords(brokerName); // Step 8: Create comprehensive keyword clusters const keywordClusters = await this.createAdvancedKeywordClusters({ expandedKeywords, competitorKeywords, questionKeywords, longTailKeywords, locationKeywords, tradingStyleKeywords }); // Step 9: Save all research results to database const savedKeywords = await this.saveComprehensiveKeywordResearch(brokerId, keywordClusters); return savedKeywords; } catch (error) { console.error('Error in comprehensive keyword research:', error); throw error; } } private async generateSeedKeywords(brokerName: string): Promise<string[]> { const baseKeywords = [ `${brokerName} review`, `${brokerName} forex broker`, `${brokerName} trading`, `${brokerName} demo account`, `${brokerName} minimum deposit`, `${brokerName} spreads`, `${brokerName} leverage`, `${brokerName} regulations`, `${brokerName} platforms`, `${brokerName} withdrawal`, `${brokerName} bonus`, `${brokerName} customer service`, `${brokerName} vs`, `${brokerName} alternative`, `${brokerName} scam`, `${brokerName} legit`, 'forex broker comparison', 'best forex brokers', 'online trading platforms', 'currency trading', 'metatrader brokers', 'ecn brokers', 'stp brokers' ]; return baseKeywords; } private async expandKeywordsWithSearch(seedKeywords: string[], brokerName: string): Promise<any[]> { const expandedKeywords = []; for (const keyword of seedKeywords.slice(0, 10)) { // Limit to avoid too many API calls try { // Use WebSearch MCP tool to find related content and extract keyword insights const searchResults = await this.performWebSearch(`${keyword} forex trading broker review`, 5); // Extract related keywords from search results const relatedKeywords = this.extractKeywordsFromSearchResults(searchResults, keyword); expandedKeywords.push(...relatedKeywords); } catch (error) { console.warn(`Failed to search for keyword "${keyword}":`, error); } } return expandedKeywords; } private extractKeywordsFromSearchResults(searchResults: any[], seedKeyword: string): any[] { const keywords = []; if (!searchResults || !Array.isArray(searchResults)) { return keywords; } for (const result of searchResults) { if (result && result.title) { // Extract keywords from titles const titleKeywords = this.extractKeywordsFromText(result.title, seedKeyword); keywords.push(...titleKeywords); } if (result && result.snippet) { // Extract keywords from snippets const snippetKeywords = this.extractKeywordsFromText(result.snippet, seedKeyword); keywords.push(...snippetKeywords); } } // Remove duplicates and return unique keywords const uniqueKeywords = Array.from(new Set(keywords)); return uniqueKeywords.map(keyword => ({ keyword, seedKeyword, source: 'web_search', confidence: this.calculateKeywordConfidence(keyword, seedKeyword) })); } private extractKeywordsFromText(text: string, seedKeyword: string): string[] { const keywords = []; // Simple keyword extraction - look for forex-related terms const forexTerms = [ 'broker', 'trading', 'forex', 'currency', 'platform', 'metatrader', 'mt4', 'mt5', 'spread', 'leverage', 'deposit', 'withdrawal', 'bonus', 'regulation', 'license', 'ecn', 'stp', 'market maker', 'demo', 'account', 'review', 'comparison', 'vs', 'alternative', 'scam', 'legit', 'minimum', 'maximum', 'fees', 'commission', 'support', 'service', 'customer', 'mobile', 'app', 'software', 'charts', 'analysis', 'signals', 'copy', 'social', 'trading', 'investment', 'pip' ]; const words = text.toLowerCase().split(/\s+/); for (let i = 0; i < words.length; i++) { const word = words[i].replace(/[^\w]/g, ''); if (forexTerms.includes(word) && word.length > 2) { // Create multi-word keywords for (let j = 1; j <= 3 && i + j < words.length; j++) { const multiWord = words.slice(i, i + j + 1).join(' '); if (multiWord.includes(seedKeyword.toLowerCase()) || forexTerms.some(term => multiWord.includes(term))) { keywords.push(multiWord); } } } } return keywords; } private calculateKeywordConfidence(keyword: string, seedKeyword: string): number { let confidence = 50; // Base confidence // Boost confidence if keyword contains seed keyword if (keyword.toLowerCase().includes(seedKeyword.toLowerCase())) { confidence += 30; } // Boost confidence for longer keywords (more specific) if (keyword.split(' ').length >= 3) { confidence += 15; } else if (keyword.split(' ').length >= 2) { confidence += 10; } // Boost confidence for transactional keywords const transactionalTerms = ['review', 'comparison', 'vs', 'alternative', 'best', 'top']; if (transactionalTerms.some(term => keyword.toLowerCase().includes(term))) { confidence += 10; } return Math.min(confidence, 100); } private async analyzeCompetitorKeywords(brokerName: string): Promise<CompetitorKeyword[]> { const competitorKeywords: CompetitorKeyword[] = []; try { // Search for broker reviews and comparisons to find competitor content const searchQueries = [ `${brokerName} vs competitors`, `best alternative to ${brokerName}`, `${brokerName} competitor analysis`, `brokers like ${brokerName}` ]; for (const query of searchQueries) { try { const results = await this.performWebSearch(query, 3); if (results && Array.isArray(results)) { for (const result of results) { const keywords = this.extractCompetitorKeywords(result, brokerName); competitorKeywords.push(...keywords); } } } catch (error) { console.warn(`Failed competitor search for "${query}":`, error); } } } catch (error) { console.error('Error in competitor keyword analysis:', error); } return competitorKeywords; } private extractCompetitorKeywords(searchResult: any, brokerName: string): CompetitorKeyword[] { const keywords: CompetitorKeyword[] = []; if (!searchResult || !searchResult.title) { return keywords; } // Extract competitor names from title const competitorNames = this.extractCompetitorNames(searchResult.title, brokerName); for (const competitor of competitorNames) { keywords.push({ keyword: `${brokerName} vs ${competitor}`, url: searchResult.url || '', position: 1, // Default position volume: 0, // Will be estimated difficulty: 50 // Default difficulty }); } return keywords; } private extractCompetitorNames(text: string, brokerName: string): string[] { const competitors = []; const knownBrokers = [ 'IG Group', 'Forex.com', 'OANDA', 'CMC Markets', 'Saxo Bank', 'Interactive Brokers', 'TD Ameritrade', 'Pepperstone', 'FxPro', 'Tickmill', 'Vantage Markets', 'Eightcap', 'Axi', 'IC Markets', 'FP Markets' ]; const words = text.split(/\s+/); for (const broker of knownBrokers) { if (text.toLowerCase().includes(broker.toLowerCase()) && broker.toLowerCase() !== brokerName.toLowerCase()) { competitors.push(broker); } } return Array.from(new Set(competitors)); } private async createKeywordClusters( expandedKeywords: any[], competitorKeywords: CompetitorKeyword[] ): Promise<KeywordCluster[]> { const clusters: KeywordCluster[] = []; // Group keywords by intent and topic const keywordGroups = this.groupKeywordsByIntent(expandedKeywords, competitorKeywords); for (const [groupName, groupKeywords] of Object.entries(keywordGroups)) { const cluster: KeywordCluster = { main_keyword: groupKeywords[0]?.keyword || groupName, cluster_name: groupName, keywords: groupKeywords.map(k => k.keyword), search_intent: this.determineSearchIntent(groupKeywords), content_type: this.determineContentType(groupName), priority: this.determinePriority(groupKeywords) }; clusters.push(cluster); } return clusters; } private groupKeywordsByIntent(expandedKeywords: any[], competitorKeywords: CompetitorKeyword[]): Record<string, any[]> { const groups: Record<string, any[]> = {}; // Review-related keywords groups.reviews = expandedKeywords.filter(k => k.keyword.toLowerCase().includes('review') || k.keyword.toLowerCase().includes('rating') || k.keyword.toLowerCase().includes('test') ); // Comparison keywords groups.comparisons = [ ...expandedKeywords.filter(k => k.keyword.toLowerCase().includes('vs') || k.keyword.toLowerCase().includes('alternative')), ...competitorKeywords ]; // Trading conditions groups.trading_conditions = expandedKeywords.filter(k => k.keyword.toLowerCase().includes('spread') || k.keyword.toLowerCase().includes('leverage') || k.keyword.toLowerCase().includes('deposit') || k.keyword.toLowerCase().includes('fee') ); // Platform and features groups.platforms = expandedKeywords.filter(k => k.keyword.toLowerCase().includes('platform') || k.keyword.toLowerCase().includes('mt4') || k.keyword.toLowerCase().includes('mt5') || k.keyword.toLowerCase().includes('mobile') ); // Educational content groups.education = expandedKeywords.filter(k => k.keyword.toLowerCase().includes('tutorial') || k.keyword.toLowerCase().includes('guide') || k.keyword.toLowerCase().includes('how to') ); return groups; } private determineSearchIntent(keywords: any[]): string { if (!keywords || keywords.length === 0) return 'informational'; const keywordText = keywords.map(k => k.keyword).join(' ').toLowerCase(); if (keywordText.includes('review') || keywordText.includes('rating')) { return 'commercial'; } else if (keywordText.includes('vs') || keywordText.includes('alternative')) { return 'commercial'; } else if (keywordText.includes('account') || keywordText.includes('deposit')) { return 'transactional'; } else if (keywordText.includes('tutorial') || keywordText.includes('guide')) { return 'informational'; } return 'informational'; } private determineContentType(clusterName: string): 'guide' | 'review' | 'comparison' | 'tutorial' | 'news' { const name = clusterName.toLowerCase(); if (name.includes('review') || name.includes('rating')) return 'review'; if (name.includes('comparison') || name.includes('vs')) return 'comparison'; if (name.includes('tutorial') || name.includes('guide')) return 'tutorial'; if (name.includes('news') || name.includes('latest')) return 'news'; return 'guide'; } private determinePriority(keywords: any[]): 'high' | 'medium' | 'low' { if (!keywords || keywords.length === 0) return 'low'; const avgConfidence = keywords.reduce((sum, k) => sum + (k.confidence || 50), 0) / keywords.length; if (avgConfidence >= 70) return 'high'; if (avgConfidence >= 50) return 'medium'; return 'low'; } private async saveKeywordResearch(brokerId: string, clusters: KeywordCluster[]): Promise<KeywordResearch[]> { const savedKeywords: KeywordResearch[] = []; try { for (const cluster of clusters) { for (const keyword of cluster.keywords) { const keywordData: KeywordResearch = { broker_id: brokerId, keyword, intent: cluster.search_intent as any, topic_cluster: cluster.cluster_name, created_at: new Date().toISOString(), updated_at: new Date().toISOString() }; // Save to database using Supabase MCP tool const saved = await this.saveKeywordToDatabase(keywordData); if (saved) { savedKeywords.push(saved); } } } } catch (error) { console.error('Error saving keyword research:', error); } return savedKeywords; } private async saveKeywordToDatabase(keywordData: KeywordResearch): Promise<KeywordResearch | null> { try { // This would use the mcp__supabase__execute_sql MCP tool console.log(`Saving keyword to database: ${keywordData.keyword}`); // Mock implementation - in real implementation, this would call the Supabase MCP tool const savedKeyword = { id: `mock_${Date.now()}`, ...keywordData }; return savedKeyword; } catch (error) { console.error('Error saving keyword to database:', error); return null; } } // New comprehensive keyword research methods private async generateComprehensiveSeedKeywords(brokerName: string): Promise<string[]> { const baseKeywords = [ // Core broker keywords `${brokerName} review`, `${brokerName} forex broker`, `${brokerName} trading`, `${brokerName} demo account`, `${brokerName} minimum deposit`, `${brokerName} spreads`, `${brokerName} leverage`, `${brokerName} regulations`, `${brokerName} platforms`, `${brokerName} withdrawal`, `${brokerName} bonus`, `${brokerName} customer service`, `${brokerName} vs`, `${brokerName} alternative`, `${brokerName} scam`, `${brokerName} legit`, // Long-tail variations `${brokerName} review 2025`, `is ${brokerName} a good forex broker`, `${brokerName} minimum deposit requirements`, `${brokerName} trading platforms explained`, `${brokerName} regulatory status check`, `${brokerName} spread costs analysis`, `${brokerName} leverage options guide`, `${brokerName} account types comparison`, `${brokerName} withdrawal process review`, `${brokerName} customer support quality`, `${brokerName} bonus terms and conditions`, `${brokerName} educational resources`, `${brokerName} mobile trading app review`, `${brokerName} copy trading features`, `${brokerName} islamic account availability`, `${brokerName} swap free account review`, `${brokerName} ECN account features`, `${brokerName} STP account comparison`, // Location-specific variations `${brokerName} USA`, `${brokerName} UK`, `${brokerName} Europe`, `${brokerName} Australia`, `${brokerName} Canada`, `${brokerName} Singapore`, `${brokerName} Dubai`, `${brokerName} South Africa`, `${brokerName} India`, `${brokerName} Nigeria`, // Trading experience level `${brokerName} for beginners`, `${brokerName} for advanced traders`, `${brokerName} for professional traders`, `${brokerName} for scalpers`, `${brokerName} for day traders`, `${brokerName} for swing traders`, `${brokerName} for position traders`, // Platform-specific `${brokerName} MT4`, `${brokerName} MT5`, `${brokerName} cTrader`, `${brokerName} WebTrader`, `${brokerName} mobile app`, // Problem/solution based `problems with ${brokerName}`, `${brokerName} solutions`, `${brokerName} alternatives`, `brokers like ${brokerName}`, `${brokerName} competitor comparison`, // Educational content `how to use ${brokerName}`, `${brokerName} tutorial`, `${brokerName} guide`, `${brokerName} tips and tricks`, `${brokerName} best practices`, // News and updates `${brokerName} news`, `${brokerName} updates 2025`, `${brokerName} changes`, `${brokerName} new features`, // Trust and safety `is ${brokerName} safe`, `${brokerName} regulation check`, `${brokerName} license verification`, `${brokerName} fund safety`, `${brokerName} trust score` ]; return baseKeywords; } private async expandKeywordsWithRealSearch(seedKeywords: string[], brokerName: string): Promise<any[]> { const expandedKeywords = []; for (const keyword of seedKeywords.slice(0, 20)) { // Process top keywords try { // Use WebSearch MCP tool to find related content and extract keyword insights const searchResults = await this.performWebSearch(`${keyword} forex trading broker review 2025`, 3); // Extract related keywords from search results const relatedKeywords = this.extractKeywordsFromSearchResults(searchResults, keyword); expandedKeywords.push(...relatedKeywords); } catch (error) { console.warn(`Failed to search for keyword "${keyword}":`, error); } } return expandedKeywords; } private async performDeepCompetitorAnalysis(brokerName: string): Promise<CompetitorKeyword[]> { const competitorKeywords: CompetitorKeyword[] = []; try { // Comprehensive competitor search queries const searchQueries = [ `${brokerName} vs competitors 2025`, `best alternative to ${brokerName}`, `${brokerName} competitor analysis`, `brokers like ${brokerName}`, `${brokerName} comparison top forex brokers`, `${brokerName} vs IG Markets`, `${brokerName} vs Forex.com`, `${brokerName} vs OANDA`, `${brokerName} vs Pepperstone`, `${brokerName} vs IC Markets` ]; for (const query of searchQueries) { try { const results = await this.performWebSearch(query, 2); if (results && Array.isArray(results)) { for (const result of results) { const keywords = this.extractCompetitorKeywords(result, brokerName); competitorKeywords.push(...keywords); } } } catch (error) { console.warn(`Failed competitor search for "${query}":`, error); } } } catch (error) { console.error('Error in competitor keyword analysis:', error); } return competitorKeywords; } private async researchQuestionKeywords(brokerName: string): Promise<string[]> { const questionKeywords = []; try { const questionPatterns = [ `is ${brokerName} a good broker`, `how does ${brokerName} work`, `what are ${brokerName} fees`, `can I trust ${brokerName}`, `does ${brokerName} accept US clients`, `is ${brokerName} regulated`, `what platforms does ${brokerName} offer`, `how to withdraw from ${brokerName}`, `what is the minimum deposit for ${brokerName}`, `does ${brokerName} have demo account`, `is ${brokerName} good for beginners`, `what leverage does ${brokerName} offer`, `does ${brokerName} offer Islamic accounts`, `how good is ${brokerName} customer service`, `what spreads does ${brokerName} offer`, `is ${brokerName} ECN or STP`, `does ${brokerName} offer copy trading`, `what are ${brokerName} account types`, `is ${brokerName} available in my country`, `how to open account with ${brokerName}` ]; for (const question of questionPatterns) { try { const results = await this.performWebSearch(question, 1); if (results && results.length > 0) { questionKeywords.push(question); // Extract related questions from search results const relatedQuestions = this.extractRelatedQuestions(results[0]); questionKeywords.push(...relatedQuestions); } } catch (error) { console.warn(`Failed to research question: ${question}`, error); } } } catch (error) { console.error('Error in question keyword research:', error); } return Array.from(new Set(questionKeywords)); // Remove duplicates } private async generateLongTailVariations(seedKeywords: string[], brokerName: string): Promise<string[]> { const longTailVariations = []; const modifiers = [ 'for beginners', 'for advanced traders', 'for professionals', 'in 2025', 'review 2025', 'guide 2025', 'with low spreads', 'with high leverage', 'with no deposit bonus', 'that accept US clients', 'that accept UK clients', 'that accept EU clients', 'MT4 download', 'MT5 download', 'mobile app', 'minimum deposit $1', 'minimum deposit $10', 'minimum deposit $100', 'ECN account', 'STP account', 'Islamic account', 'swap free account', 'demo account', 'live account', 'standard account', 'premium account', 'customer service review', 'withdrawal review', 'deposit review', 'regulation check', 'license verification', 'safety review', 'comparison with competitors', 'vs IG Markets', 'vs Forex.com', 'vs OANDA', 'trading conditions', 'fees and commissions', 'spreads explained', 'platform review', 'mobile app review', 'web trader review', 'copy trading', 'social trading', 'automated trading', 'manual trading', 'forex trading', 'CFD trading', 'crypto trading', 'commodities trading', 'scalping friendly', 'day trading friendly', 'swing trading friendly', 'high frequency trading', 'position trading', 'long term trading', 'educational resources', 'trading tools', 'market analysis', 'economic calendar', 'trading signals', 'technical analysis', 'fundamental analysis', 'risk management', 'trading psychology' ]; for (const keyword of seedKeywords.slice(0, 50)) { for (const modifier of modifiers.slice(0, 10)) { if (keyword.length + modifier.length < 80) { // Keep reasonable length longTailVariations.push(`${keyword} ${modifier}`); } } } return Array.from(new Set(longTailVariations)); } private async researchLocationKeywords(brokerName: string): Promise<string[]> { const locations = [ 'USA', 'United States', 'UK', 'United Kingdom', 'Europe', 'Australia', 'Canada', 'Singapore', 'Dubai', 'UAE', 'South Africa', 'India', 'Nigeria', 'Kenya', 'Malaysia', 'Thailand', 'Vietnam', 'Philippines', 'Indonesia', 'Japan', 'South Korea', 'China', 'Hong Kong', 'Taiwan', 'Brazil', 'Argentina', 'Mexico', 'Chile', 'Colombia', 'Peru', 'Germany', 'France', 'Italy', 'Spain', 'Netherlands', 'Switzerland', 'Sweden', 'Norway', 'Denmark', 'Finland', 'Poland', 'Russia', 'Turkey', 'Israel', 'Saudi Arabia', 'Egypt', 'South Africa', 'Nigeria' ]; const locationKeywords = []; for (const location of locations) { locationKeywords.push( `${brokerName} ${location}`, `${brokerName} review ${location}`, `${brokerName} traders ${location}`, `is ${brokerName} available in ${location}`, `${brokerName} regulation ${location}`, `${brokerName} minimum deposit ${location}` ); } return locationKeywords; } private async researchTradingStyleKeywords(brokerName: string): Promise<string[]> { const tradingStyles = [ 'scalping', 'day trading', 'swing trading', 'position trading', 'long term trading', 'short term trading', 'high frequency trading', 'algorithmic trading', 'automated trading', 'manual trading', 'copy trading', 'social trading', 'mirror trading', 'news trading', 'technical analysis', 'fundamental analysis', 'price action trading', 'indicator trading', 'pattern trading' ]; const tradingStyleKeywords = []; for (const style of tradingStyles) { tradingStyleKeywords.push( `${brokerName} for ${style}`, `${brokerName} ${style} review`, `is ${brokerName} good for ${style}`, `${brokerName} ${style} strategy`, `${brokerName} ${style} platform`, `${brokerName} ${style} account`, `${brokerName} ${style} conditions`, `${brokerName} ${style} fees`, `${brokerName} ${style} spread`, `${brokerName} ${style} leverage` ); } return tradingStyleKeywords; } private async createAdvancedKeywordClusters(data: any): Promise<KeywordCluster[]> { const clusters: KeywordCluster[] = []; // Comprehensive clustering by content type and intent const clusterGroups = { broker_reviews: { main_keyword: `${data.expandedKeywords[0]?.keyword || 'broker'} review`, cluster_name: 'broker_reviews', keywords: data.expandedKeywords.filter(k => k.keyword.includes('review') || k.keyword.includes('rating')), search_intent: 'commercial', content_type: 'review', priority: 'high' }, broker_comparisons: { main_keyword: 'broker comparison', cluster_name: 'broker_comparisons', keywords: [ ...data.expandedKeywords.filter(k => k.keyword.includes('vs') || k.keyword.includes('comparison')), ...data.competitorKeywords ], search_intent: 'commercial', content_type: 'comparison', priority: 'high' }, trading_conditions: { main_keyword: 'trading conditions', cluster_name: 'trading_conditions', keywords: data.expandedKeywords.filter(k => k.keyword.includes('spread') || k.keyword.includes('leverage') || k.keyword.includes('deposit') || k.keyword.includes('fee') ), search_intent: 'informational', content_type: 'guide', priority: 'medium' }, platform_reviews: { main_keyword: 'trading platforms', cluster_name: 'platform_reviews', keywords: data.expandedKeywords.filter(k => k.keyword.includes('platform') || k.keyword.includes('mt4') || k.keyword.includes('mt5') || k.keyword.includes('mobile') ), search_intent: 'informational', content_type: 'review', priority: 'medium' }, educational_content: { main_keyword: 'forex education', cluster_name: 'educational_content', keywords: data.expandedKeywords.filter(k => k.keyword.includes('tutorial') || k.keyword.includes('guide') || k.keyword.includes('how to') || k.keyword.includes('beginner') ), search_intent: 'informational', content_type: 'tutorial', priority: 'medium' }, question_answers: { main_keyword: 'broker questions', cluster_name: 'question_answers', keywords: data.questionKeywords, search_intent: 'informational', content_type: 'faq', priority: 'medium' }, location_specific: { main_keyword: 'brokers by location', cluster_name: 'location_specific', keywords: data.locationKeywords, search_intent: 'informational', content_type: 'guide', priority: 'low' }, trading_styles: { main_keyword: 'trading styles', cluster_name: 'trading_styles', keywords: data.tradingStyleKeywords, search_intent: 'informational', content_type: 'guide', priority: 'low' } }; for (const [groupName, clusterData] of Object.entries(clusterGroups)) { if (clusterData.keywords.length > 0) { clusters.push({ main_keyword: clusterData.main_keyword, cluster_name: clusterData.cluster_name, keywords: clusterData.keywords.map(k => k.keyword || k), search_intent: clusterData.search_intent, content_type: clusterData.content_type as "guide" | "review" | "comparison" | "tutorial" | "news", priority: clusterData.priority as "high" | "low" | "medium" }); } } return clusters; } private async saveComprehensiveKeywordResearch(brokerId: string, clusters: KeywordCluster[]): Promise<KeywordResearch[]> { const savedKeywords: KeywordResearch[] = []; try { for (const cluster of clusters) { for (const keyword of cluster.keywords.slice(0, 20)) { // Limit per cluster const keywordData: KeywordResearch = { broker_id: brokerId, keyword, intent: cluster.search_intent as any, topic_cluster: cluster.cluster_name, created_at: new Date().toISOString(), updated_at: new Date().toISOString() }; const saved = await this.saveKeywordToDatabase(keywordData); if (saved) { savedKeywords.push(saved); } } } } catch (error) { console.error('Error saving comprehensive keyword research:', error); } return savedKeywords; } private extractRelatedQuestions(searchResult: any): string[] { const questions = []; // Extract question patterns from search results const questionPatterns = [ /(?:What|How|When|Where|Why|Which|Who|Is|Are|Can|Should|Do|Does)\s+.*?\?/g ]; if (searchResult && searchResult.snippet) { const matches = searchResult.snippet.match(questionPatterns); if (matches) { questions.push(...matches); } } return questions; } async getKeywordResearch(brokerId: string): Promise<KeywordResearch[]> { try { // This would use the mcp__supabase__execute_sql MCP tool console.log(`Fetching keyword research for broker: ${brokerId}`); // Mock implementation - in real implementation, this would call the Supabase MCP tool return []; } catch (error) { console.error('Error fetching keyword research:', error); return []; } } async getKeywordClusters(brokerId: string): Promise<KeywordCluster[]> { try { const keywords = await this.getKeywordResearch(brokerId); // Group keywords by cluster const clusters: Record<string, KeywordCluster> = {}; for (const keyword of keywords) { if (!clusters[keyword.topic_cluster]) { clusters[keyword.topic_cluster] = { main_keyword: keyword.keyword, cluster_name: keyword.topic_cluster, keywords: [], search_intent: keyword.intent, content_type: this.determineContentType(keyword.topic_cluster), priority: 'medium' }; } clusters[keyword.topic_cluster].keywords.push(keyword.keyword); } return Object.values(clusters); } catch (error) { console.error('Error fetching keyword clusters:', error); return []; } } } // Blog Content Optimization Extensions export interface BlogPostSEOData { primaryKeyword: string secondaryKeywords: string[] lsiKeywords: string[] searchIntent: 'informational' | 'commercial' | 'navigational' | 'transactional' targetAudience: 'beginner' | 'intermediate' | 'advanced' | 'all' contentDepth: 'basic' | 'comprehensive' | 'expert' wordCountTarget: number } export interface ContentSection { title: string level: number content: string wordCount: number keyPoints: string[] } export interface FAQItem { question: string answer: string keywords: string[] } export interface InternalLink { text: string url: string title: string relevance: 'high' | 'medium' | 'low' } export interface ExternalLink { text: string url: string source: string authority: number } export class BlogContentOptimizer { private keywordResearch: KeywordResearchAgent constructor(keywordResearch: KeywordResearchAgent) { this.keywordResearch = keywordResearch } async optimizeBlogPost( title: string, targetKeyword: string, sections: ContentSection[], faqQuestions: string[] ): Promise<{ seoTitle: string seoDescription: string optimizedSections: ContentSection[] faq: FAQItem[] internalLinks: InternalLink[] externalLinks: ExternalLink[] readingTime: number keyTakeaways: string[] }> { // Get keyword data (placeholder implementation) const keywordData = { volume: 1000, difficulty: 50, intent: 'informational' } const relatedKeywords = [targetKeyword] // Generate SEO components const seoTitle = this.generateSEOTitle(title, targetKeyword) const seoDescription = this.generateSEODescription(sections, targetKeyword) const optimizedSections = this.optimizeSections(sections, targetKeyword, relatedKeywords) const faq = this.generateFAQ(faqQuestions, targetKeyword) const internalLinks = this.generateInternalLinks(targetKeyword) const externalLinks = this.generateExternalLinks(targetKeyword) const readingTime = this.calculateReadingTime(optimizedSections) const keyTakeaways = this.generateKeyTakeaways(optimizedSections) return { seoTitle, seoDescription, optimizedSections, faq, internalLinks, externalLinks, readingTime, keyTakeaways } } private generateSEOTitle(title: string, keyword: string): string { const currentYear = new Date().getFullYear() if (!title.toLowerCase().includes(keyword.toLowerCase())) { title = `${keyword}: ${title}` } if (!title.includes(currentYear.toString())) { title = `${title}: ${currentYear} Guide` } // Ensure optimal length (50-60 characters) if (title.length < 50) { title += ` - ${currentYear}` } else if (title.length > 60) { title = title.substring(0, 57) + '...' } return title } private generateSEODescription(sections: ContentSection[], keyword: string): string { const firstSection = sections[0] const introduction = firstSection.content.substring(0, 100) let description = `${introduction}... Learn about ${keyword}. Discover expert tips, strategies, and insights for successful trading.` if (description.length > 160) { description = description.substring(0, 157) + '...' } return description } private optimizeSections( sections: ContentSection[], primaryKeyword: string, relatedKeywords: string[] ): ContentSection[] { return sections.map((section, index) => ({ ...section, content: this.enhanceContentWithKeywords(section.content, primaryKeyword, relatedKeywords, section.level), id: `section-${index + 1}` })) } private enhanceContentWithKeywords( content: string, primaryKeyword: string, relatedKeywords: string[], level: number ): string { if (level !== 2) return content let enhancedContent = content if (!content.toLowerCase().includes(primaryKeyword.toLowerCase())) { enhancedContent = `${primaryKeyword}: ${enhancedContent}` } if (enhancedContent.length > 300 && relatedKeywords.length > 0) { const keyword = relatedKeywords[Math.floor(Math.random() * relatedKeywords.length)] if (!enhancedContent.toLowerCase().includes(keyword.toLowerCase())) { enhancedContent += ` Understanding ${keyword} is also crucial for success.` } } return enhancedContent } private generateFAQ(questions: string[], keyword: string): FAQItem[] { return questions.map(question => ({ question, answer: this.generateFAQAnswer(question, keyword), keywords: [keyword] })) } private generateFAQAnswer(question: string, keyword: string): string { if (question.toLowerCase().includes('what is')) { return `${keyword} is a comprehensive approach to currency trading that requires proper education, risk management, and the right broker selection.` } if (question.toLowerCase().includes('how much')) { return `The capital required for ${keyword} varies based on your trading style and risk tolerance. Most successful traders start with $5,000-$10,000.` } if (question.toLowerCase().includes('best broker')) { return `The best brokers for ${keyword} offer competitive spreads, reliable execution, strong regulation, and educational resources.` } return `Success in ${keyword} requires dedication to continuous learning, proper risk management, and emotional discipline.` } private generateInternalLinks(keyword: string): InternalLink[] { return [ { text: 'best forex brokers', url: '/blog/best-forex-brokers', title: 'Top Rated Forex Brokers for 2025', relevance: 'high' }, { text: 'forex trading strategies', url: '/blog/forex-trading-strategies', title: 'Proven Trading Strategies', relevance: 'high' }, { text: 'risk management guide', url: '/blog/risk-management-forex', title: 'Complete Risk Management Guide', relevance: 'medium' } ] } private generateExternalLinks(keyword: string): ExternalLink[] { return [ { text: 'BIS Triennial Central Bank Survey', url: 'https://www.bis.org/publ/rpfx19.htm', source: 'Bank for International Settlements', authority: 10 }, { text: 'CFTC Forex Fraud Advisory', url: 'https://www.cftc.gov/LearnAndProtect/Advisories/FraudAdvisories/fxforexadvisory', source: 'Commodity Futures Trading Commission', authority: 9 } ] } private calculateReadingTime(sections: ContentSection[]): number { const totalWords = sections.reduce((total, section) => total + section.wordCount, 0) return Math.ceil(totalWords / 225) } private generateKeyTakeaways(sections: ContentSection[]): string[] { const takeaways: string[] = [] sections.forEach(section => { if (section.keyPoints.length > 0) { takeaways.push(section.keyPoints[0]) } }) while (takeaways.length < 4 && takeaways.length < sections.length) { const section = sections[takeaways.length] if (section.content.length > 100) { takeaways.push(`Learn about ${section.title.toLowerCase()}`) } } return takeaways.slice(0, 5) } }