import { DailyContentProductionService } from './daily-content-production'; import { AnalyticsService } from './analytics-service'; import { supabase } from './supabase'; import type { DailyContentPlan, ContentProductionResult } from './daily-content-production'; export interface ProductionWorkflowConfig { execution_time: string; // HH:MM format timezone: string; max_daily_content: number; quality_threshold: number; seo_threshold: number; auto_publish: boolean; distribution_enabled: boolean; notification_enabled: boolean; } export interface WorkflowExecution { id: string; execution_date: string; status: 'pending' | 'running' | 'completed' | 'failed'; plan: DailyContentPlan; result?: ContentProductionResult; started_at?: string; completed_at?: string; error?: string; performance_metrics: { execution_time: number; success_rate: number; content_quality_score: number; seo_optimization_score: number; }; } export class ContentProductionWorkflow { private productionService: DailyContentProductionService; private analyticsService: AnalyticsService; private config: ProductionWorkflowConfig; private executionHistory: WorkflowExecution[] = []; constructor(config?: Partial<ProductionWorkflowConfig>) { this.productionService = new DailyContentProductionService(); this.analyticsService = new AnalyticsService({ tracking_id: 'content_production_workflow', data_sources: ['workflow_executions', 'content_metrics', 'production_stats'], update_frequency: 1800, // 30 minutes retention_period: 30, alert_thresholds: { traffic_decline: 15, conversion_rate_drop: 10, bounce_rate_increase: 20, page_load_time: 2, error_rate: 3 } }); this.config = { execution_time: '09:00', timezone: 'UTC', max_daily_content: 3, quality_threshold: 85, seo_threshold: 80, auto_publish: true, distribution_enabled: true, notification_enabled: true, ...config }; } async executeDailyWorkflow(customDate?: string): Promise<WorkflowExecution> { const execution: WorkflowExecution = { id: `workflow_${Date.now()}`, execution_date: customDate || new Date().toISOString().split('T')[0], status: 'pending', plan: null as any, performance_metrics: { execution_time: 0, success_rate: 0, content_quality_score: 0, seo_optimization_score: 0 } }; try { console.log(`üöÄ Starting daily content production workflow for ${execution.execution_date}`); execution.status = 'running'; execution.started_at = new Date().toISOString(); // Step 1: Generate daily content plan console.log('üìã Generating daily content plan...'); const plan = await this.productionService.generateDailyContentPlan(execution.execution_date); execution.plan = plan; console.log(`üìÖ Plan generated for ${plan.date}:`); console.log(` ‚Ä¢ Target articles: ${plan.target_count}`); console.log(` ‚Ä¢ Content types: ${plan.content_types.join(', ')}`); console.log(` ‚Ä¢ Priority keywords: ${plan.priority_keywords.slice(0, 5).join(', ')}`); // Step 2: Execute content production console.log('üìù Executing content production...'); const startTime = Date.now(); const result = await this.productionService.executeDailyProduction(plan); const executionTime = Date.now() - startTime; execution.result = result; execution.completed_at = new Date().toISOString(); execution.status = result.success ? 'completed' : 'failed'; execution.performance_metrics = { execution_time: executionTime, success_rate: result.success ? 100 : 0, content_quality_score: result.performance_metrics.average_quality_score, seo_optimization_score: result.performance_metrics.average_seo_score }; // Step 3: Log workflow execution await this.logWorkflowExecution(execution); // Step 4: Generate insights and recommendations const insights = await this.generateWorkflowInsights(execution); await this.storeInsights(insights); // Step 5: Send notifications if enabled if (this.config.notification_enabled) { await this.sendWorkflowNotification(execution); } // Step 6: Update content calendar for next day await this.updateContentCalendar(); console.log(`‚úÖ Daily workflow ${execution.status}!`); console.log(`‚è±Ô∏è Execution time: ${Math.round(executionTime / 1000)}s`); console.log(`üìä Content created: ${result.content_created}/${plan.target_count}`); console.log(`üìà Quality score: ${result.performance_metrics.average_quality_score.toFixed(1)}`); console.log(`üîç SEO score: ${result.performance_metrics.average_seo_score.toFixed(1)}`); return execution; } catch (error) { execution.status = 'failed'; execution.error = error instanceof Error ? error.message : 'Unknown error'; execution.completed_at = new Date().toISOString(); console.error('üí• Workflow execution failed:', error); await this.logWorkflowExecution(execution); if (this.config.notification_enabled) { await this.sendErrorNotification(execution); } return execution; } } async setupScheduledExecution(): Promise<void> { console.log('‚è∞ Setting up scheduled content production...'); // Calculate next execution time const nextExecution = this.calculateNextExecutionTime(); console.log(`üìÖ Next execution scheduled for: ${nextExecution.toISOString()}`); // Setup interval for checking execution time const checkInterval = setInterval(async () => { const now = new Date(); const currentTime = now.toTimeString().slice(0, 5); // HH:MM format if (currentTime === this.config.execution_time) { console.log('üéØ Execution time reached, starting workflow...'); // Execute workflow const execution = await this.executeDailyWorkflow(); // Calculate next execution time const nextExecution = this.calculateNextExecutionTime(); console.log(`üìÖ Next execution scheduled for: ${nextExecution.toISOString()}`); } }, 60000); // Check every minute // Store interval ID for cleanup (global as any).contentProductionInterval = checkInterval; } async executeBulkProduction(days: number): Promise<WorkflowExecution[]> { console.log(`üöÄ Starting bulk content production for ${days} days...`); const executions: WorkflowExecution[] = []; for (let i = 0; i < days; i++) { const targetDate = new Date(); targetDate.setDate(targetDate.getDate() + i); console.log(`üìÖ Processing day ${i + 1}/${days}: ${targetDate.toISOString().split('T')[0]}`); const execution = await this.executeDailyWorkflow(targetDate.toISOString().split('T')[0]); executions.push(execution); // Small delay between executions to avoid rate limits if (i < days - 1) { await new Promise(resolve => setTimeout(resolve, 5000)); } } // Generate bulk summary const summary = await this.generateBulkSummary(executions); console.log('üìä Bulk Production Summary:'); console.log(` ‚Ä¢ Total executions: ${executions.length}`); console.log(` ‚Ä¢ Successful: ${executions.filter(e => e.status === 'completed').length}`); console.log(` ‚Ä¢ Failed: ${executions.filter(e => e.status === 'failed').length}`); console.log(` ‚Ä¢ Total content created: ${summary.total_content_created}`); console.log(` ‚Ä¢ Average quality: ${summary.average_quality_score.toFixed(1)}`); console.log(` ‚Ä¢ Average SEO: ${summary.average_seo_score.toFixed(1)}`); return executions; } async getWorkflowStats(_timeframe: string = '7d'): Promise<any> { const { data, error } = await supabase .from('workflow_executions') .select('*') .gte('execution_date', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()) .order('execution_date', { ascending: false }); if (error) { console.error('Error fetching workflow stats:', error); return null; } // Calculate comprehensive statistics const stats = { total_executions: data?.length || 0, successful_executions: data?.filter(e => e.status === 'completed').length || 0, failed_executions: data?.filter(e => e.status === 'failed').length || 0, success_rate: data?.length > 0 ? (data.filter(e => e.status === 'completed').length / data.length) * 100 : 0, total_content_created: data?.reduce((sum, e) => sum + (e.result?.content_created || 0), 0) || 0, total_words_generated: data?.reduce((sum, e) => sum + (e.result?.performance_metrics?.total_word_count || 0), 0) || 0, average_quality_score: data?.length > 0 ? data.reduce((sum, e) => sum + (e.result?.performance_metrics?.average_quality_score || 0), 0) / data.length : 0, average_seo_score: data?.length > 0 ? data.reduce((sum, e) => sum + (e.result?.performance_metrics?.average_seo_score || 0), 0) / data.length : 0, average_execution_time: data?.length > 0 ? data.reduce((sum, e) => sum + (e.performance_metrics?.execution_time || 0), 0) / data.length : 0, top_performing_days: this.getTopPerformingDays(data || []), common_errors: this.getCommonErrors(data || []), efficiency_trend: this.calculateEfficiencyTrend(data || []), recent_improvements: this.identifyRecentImprovements(data || []) }; return stats; } private calculateNextExecutionTime(): Date { const now = new Date(); const [hours, minutes] = this.config.execution_time.split(':').map(Number); const nextExecution = new Date(); nextExecution.setHours(hours, minutes, 0, 0); // If execution time has passed today, schedule for tomorrow if (nextExecution <= now) { nextExecution.setDate(nextExecution.getDate() + 1); } return nextExecution; } private async logWorkflowExecution(execution: WorkflowExecution): Promise<void> { const { error } = await supabase .from('workflow_executions') .insert({ id: execution.id, execution_date: execution.execution_date, status: execution.status, plan: execution.plan, result: execution.result, started_at: execution.started_at, completed_at: execution.completed_at, error: execution.error, performance_metrics: execution.performance_metrics }); if (error) { console.error('Error logging workflow execution:', error); } } private async generateWorkflowInsights(execution: WorkflowExecution): Promise<any> { const insights = { execution_id: execution.id, execution_date: execution.execution_date, content_performance_analysis: await this.analyzeContentPerformance(execution), quality_trends: await this.analyzeQualityTrends(execution), efficiency_metrics: this.calculateEfficiencyMetrics(execution), recommendations: await this.generateRecommendations(execution), optimization_opportunities: await this.identifyOptimizationOpportunities(execution) }; return insights; } private async analyzeContentPerformance(execution: WorkflowExecution): Promise<any> { if (!execution.result?.content_ids || execution.result.content_ids.length === 0) { return { message: 'No content created for performance analysis' }; } const contentAnalytics = await Promise.all( execution.result.content_ids.map(contentId => this.analyticsService.getContentAnalytics(contentId, '1d') ) ); return { content_analyzed: contentAnalytics.length, average_page_views: contentAnalytics.reduce((sum, analytics) => sum + (analytics.performance?.page_views || 0), 0) / contentAnalytics.length, average_engagement_rate: contentAnalytics.reduce((sum, analytics) => sum + (analytics.engagement?.engagement_rate || 0), 0) / contentAnalytics.length, top_performing_content: contentAnalytics .sort((a, b) => (b.performance?.page_views || 0) - (a.performance?.page_views || 0)) .slice(0, 3) .map(analytics => analytics.content_id), content_needs_attention: contentAnalytics .filter(analytics => (analytics.performance?.page_views || 0) < 50) .map(analytics => analytics.content_id) }; } private async analyzeQualityTrends(_execution: WorkflowExecution): Promise<any> { const recentExecutions = await this.getRecentExecutions(7); // Last 7 days if (recentExecutions.length < 2) { return { message: 'Insufficient data for quality trend analysis' }; } const qualityScores = recentExecutions.map(e => e.result?.performance_metrics?.average_quality_score || 0 ); return { trend_direction: this.calculateTrendDirection(qualityScores), average_quality: qualityScores.reduce((sum, score) => sum + score, 0) / qualityScores.length, quality_improvement: qualityScores[qualityScores.length - 1] - qualityScores[0], consistency_score: this.calculateConsistencyScore(qualityScores), quality_predictions: this.predictQualityTrend(qualityScores) }; } private calculateEfficiencyMetrics(execution: WorkflowExecution): any { return { execution_time_efficiency: this.calculateTimeEfficiency(execution), content_production_rate: this.calculateProductionRate(execution), resource_utilization: this.calculateResourceUtilization(execution), bottleneck_identification: this.identifyBottlenecks(execution) }; } private async generateRecommendations(execution: WorkflowExecution): Promise<string[]> { const recommendations: string[] = []; // Quality-based recommendations if ((execution.result?.performance_metrics?.average_quality_score || 0) < this.config.quality_threshold) { recommendations.push('Consider increasing quality assurance review time'); } // SEO-based recommendations if ((execution.result?.performance_metrics?.average_seo_score || 0) < this.config.seo_threshold) { recommendations.push('Enhance SEO optimization process for better rankings'); } // Efficiency-based recommendations if (execution.performance_metrics.execution_time > 300000) { // 5 minutes recommendations.push('Optimize content generation speed for better efficiency'); } // Success rate recommendations if (execution.result?.success === false) { recommendations.push('Review error handling and retry mechanisms'); } return recommendations; } private async identifyOptimizationOpportunities(execution: WorkflowExecution): Promise<any[]> { const opportunities = []; // Check for content type performance const contentPerformance = await this.analyzeContentTypePerformance(); if (contentPerformance.underperforming.length > 0) { opportunities.push({ area: 'content_type_optimization', description: `Underperforming content types: ${contentPerformance.underperforming.join(', ')}`, potential_impact: 'medium', effort: 'low' }); } // Check for keyword performance const keywordPerformance = await this.analyzeKeywordPerformance(); if (keywordPerformance.low_performing.length > 0) { opportunities.push({ area: 'keyword_strategy', description: `${keywordPerformance.low_performing.length} keywords showing low performance`, potential_impact: 'high', effort: 'medium' }); } // Check for distribution effectiveness if ((execution.result?.content_published || 0) < (execution.result?.content_created || 0)) { opportunities.push({ area: 'distribution_optimization', description: 'Improve content distribution publishing rate', potential_impact: 'medium', effort: 'high' }); } return opportunities; } private async storeInsights(insights: any): Promise<void> { const { error } = await supabase .from('workflow_insights') .insert(insights); if (error) { console.error('Error storing workflow insights:', error); } } private async sendWorkflowNotification(execution: WorkflowExecution): Promise<void> { // Implementation for sending notifications (email, Slack, etc.) console.log(`üìß Sending workflow notification for execution ${execution.id}`); const message = { type: execution.status === 'completed' ? 'success' : 'error', title: `Daily Content Production - ${execution.status.toUpperCase()}`, content: this.formatNotificationMessage(execution), timestamp: new Date().toISOString() }; // Store notification in database for external systems to pick up await supabase .from('workflow_notifications') .insert(message); } private async sendErrorNotification(execution: WorkflowExecution): Promise<void> { console.log(`üö® Sending error notification for execution ${execution.id}`); const message = { type: 'critical', title: 'Content Production Workflow Failed', content: `Execution ${execution.id} failed: ${execution.error}`, timestamp: new Date().toISOString() }; await supabase .from('workflow_notifications') .insert(message); } private async updateContentCalendar(): Promise<void> { // Update content calendar for future days based on performance const stats = await this.getWorkflowStats('7d'); if (stats && stats.success_rate > 80) { // Consider increasing daily target if consistently successful console.log('üìà High success rate detected, consider increasing daily content targets'); } } private formatNotificationMessage(execution: WorkflowExecution): string { const result = execution.result; const metrics = execution.performance_metrics; return ` Daily Content Production Summary: ‚Ä¢ Status: ${execution.status} ‚Ä¢ Date: ${execution.execution_date} ‚Ä¢ Content Created: ${result?.content_created || 0}/${execution.plan?.target_count || 0} ‚Ä¢ Words Written: ${result?.performance_metrics?.total_word_count?.toLocaleString() || 0} ‚Ä¢ Quality Score: ${result?.performance_metrics?.average_quality_score?.toFixed(1) || 'N/A'} ‚Ä¢ SEO Score: ${result?.performance_metrics?.average_seo_score?.toFixed(1) || 'N/A'} ‚Ä¢ Execution Time: ${Math.round(metrics.execution_time / 1000)}s `.trim(); } // Helper methods for statistics and analysis private async getRecentExecutions(days: number): Promise<WorkflowExecution[]> { const { data } = await supabase .from('workflow_executions') .select('*') .gte('execution_date', new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString()) .order('execution_date', { ascending: false }); return data || []; } private calculateTrendDirection(scores: number[]): 'improving' | 'declining' | 'stable' { if (scores.length < 2) return 'stable'; const recent = scores.slice(-3); const earlier = scores.slice(0, 3); const recentAvg = recent.reduce((sum, score) => sum + score, 0) / recent.length; const earlierAvg = earlier.reduce((sum, score) => sum + score, 0) / earlier.length; const difference = recentAvg - earlierAvg; if (difference > 5) return 'improving'; if (difference < -5) return 'declining'; return 'stable'; } private calculateConsistencyScore(scores: number[]): number { if (scores.length === 0) return 0; const mean = scores.reduce((sum, score) => sum + score, 0) / scores.length; const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length; const standardDeviation = Math.sqrt(variance); // Lower standard deviation = higher consistency return Math.max(0, 100 - (standardDeviation / mean) * 100); } private predictQualityTrend(scores: number[]): string { if (scores.length < 3) return 'insufficient_data'; // Simple linear regression for trend prediction const n = scores.length; const x = Array.from({ length: n }, (_, i) => i); const y = scores; const xMean = x.reduce((sum, val) => sum + val, 0) / n; const yMean = y.reduce((sum, val) => sum + val, 0) / n; const numerator = x.reduce((sum, xi, i) => sum + (xi - xMean) * (y[i] - yMean), 0); const denominator = x.reduce((sum, xi) => sum + Math.pow(xi - xMean, 2), 0); const slope = denominator !== 0 ? numerator / denominator : 0; if (slope > 1) return 'improving'; if (slope < -1) return 'declining'; return 'stable'; } private calculateTimeEfficiency(execution: WorkflowExecution): number { const targetTime = 180000; // 3 minutes target const actualTime = execution.performance_metrics.execution_time; return Math.max(0, 100 - (actualTime / targetTime) * 100); } private calculateProductionRate(execution: WorkflowExecution): number { const contentCreated = execution.result?.content_created || 0; const executionTime = execution.performance_metrics.execution_time / 1000 / 60; // in minutes return executionTime > 0 ? contentCreated / executionTime : 0; } private calculateResourceUtilization(execution: WorkflowExecution): number { // Simple utilization based on success rate and quality const successRate = execution.result?.success ? 100 : 0; const qualityScore = execution.result?.performance_metrics?.average_quality_score || 0; return (successRate + qualityScore) / 2; } private identifyBottlenecks(execution: WorkflowExecution): string[] { const bottlenecks = []; if (execution.performance_metrics.execution_time > 300000) { bottlenecks.push('content_generation_time'); } if ((execution.result?.content_created || 0) < (execution.plan?.target_count || 0)) { bottlenecks.push('content_creation_capacity'); } if ((execution.result?.content_published || 0) < (execution.result?.content_created || 0)) { bottlenecks.push('distribution_publishing'); } return bottlenecks; } private async analyzeContentTypePerformance(): Promise<any> { // Implementation for analyzing content type performance return { top_performing: ['blog_post', 'market_analysis'], underperforming: ['educational_content'], recommendations: ['Focus more on blog posts and market analysis'] }; } private async analyzeKeywordPerformance(): Promise<any> { // Implementation for analyzing keyword performance return { high_performing: ['forex broker review', 'trading strategies'], low_performing: ['beginner forex guide'], recommendations: ['Optimize beginner-focused content'] }; } private getTopPerformingDays(executions: any[]): any[] { return executions .filter(e => e.status === 'completed') .sort((a, b) => (b.result?.content_created || 0) - (a.result?.content_created || 0)) .slice(0, 5) .map(e => ({ date: e.execution_date, content_created: e.result?.content_created || 0, quality_score: e.result?.performance_metrics?.average_quality_score || 0 })); } private getCommonErrors(executions: any[]): any[] { const errorCounts = new Map<string, number>(); executions.forEach(execution => { if (execution.result?.errors) { execution.result.errors.forEach((error: string) => { errorCounts.set(error, (errorCounts.get(error) || 0) + 1); }); } }); return Array.from(errorCounts.entries()) .sort((a, b) => b[1] - a[1]) .slice(0, 5) .map(([error, count]) => ({ error, count })); } private calculateEfficiencyTrend(executions: any[]): any { if (executions.length < 2) return { trend: 'insufficient_data' }; const recentEfficiency = executions.slice(-5).map(e => { const successRate = e.result?.success ? 100 : 0; const quality = e.result?.performance_metrics?.average_quality_score || 0; return (successRate + quality) / 2; }); const trend = this.calculateTrendDirection(recentEfficiency); return { trend, average_efficiency: recentEfficiency.reduce((sum, e) => sum + e, 0) / recentEfficiency.length }; } private identifyRecentImprovements(executions: any[]): string[] { const improvements = []; // Check for recent improvements in quality const recentQuality = executions.slice(-3).map(e => e.result?.performance_metrics?.average_quality_score || 0 ); const earlierQuality = executions.slice(-6, -3).map(e => e.result?.performance_metrics?.average_quality_score || 0 ); if (recentQuality.length > 0 && earlierQuality.length > 0) { const recentAvg = recentQuality.reduce((sum, q) => sum + q, 0) / recentQuality.length; const earlierAvg = earlierQuality.reduce((sum, q) => sum + q, 0) / earlierQuality.length; if (recentAvg > earlierAvg + 5) { improvements.push('Content quality has improved in recent executions'); } } return improvements; } private async generateBulkSummary(executions: WorkflowExecution[]): Promise<any> { return { total_executions: executions.length, successful_executions: executions.filter(e => e.status === 'completed').length, total_content_created: executions.reduce((sum, e) => sum + (e.result?.content_created || 0), 0), total_words_generated: executions.reduce((sum, e) => sum + (e.result?.performance_metrics?.total_word_count || 0), 0), average_quality_score: executions.length > 0 ? executions.reduce((sum, e) => sum + (e.result?.performance_metrics?.average_quality_score || 0), 0) / executions.length : 0, average_seo_score: executions.length > 0 ? executions.reduce((sum, e) => sum + (e.result?.performance_metrics?.average_seo_score || 0), 0) / executions.length : 0, total_execution_time: executions.reduce((sum, e) => sum + (e.performance_metrics?.execution_time || 0), 0) }; } }