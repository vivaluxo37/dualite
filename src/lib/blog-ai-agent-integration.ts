import { EnhancedSEOContentWorkflow } from './enhanced-seo-content-workflow' import { supabase } from './supabase' import { Task } from './Task' /** * Blog System Integration with SEO AI Agents * Connects the blog system to the enhanced SEO workflow */ export interface BlogContentRequest { topic: string categoryId?: string tags?: string[] targetKeywords?: string[] authorId?: string publishImmediately?: boolean featured?: boolean } export interface BlogContentResult { success: boolean postId?: string content?: string seoData?: any errors?: string[] } export class BlogAIAgentIntegration { private seoWorkflow: EnhancedSEOContentWorkflow constructor() { this.seoWorkflow = new EnhancedSEOContentWorkflow({ projectId: 'brokeranalysis-blog', contentStrategy: 'blog', optimizationLevel: 'enterprise', publishingSchedule: 'manual', qualityThreshold: 85 }) } /** * Generate complete blog post using AI agents */ async generateBlogPost(request: BlogContentRequest): Promise<BlogContentResult> { try { console.log(`ü§ñ Starting AI blog post generation for: ${request.topic}`) // Step 1: Get category and tag information const categoryInfo = await this.getCategoryInfo(request.categoryId) const tagInfo = await this.getTagInfo(request.tags) // Step 2: Execute enhanced SEO workflow const workflowResult = await this.seoWorkflow.executeFullWorkflow(request.topic, { category: categoryInfo, tags: tagInfo, keywords: request.targetKeywords }) if (!workflowResult.success) { return { success: false, errors: workflowResult.errors } } // Step 3: Format content for blog system const blogContent = await this.formatBlogContent(workflowResult, request) // Step 4: Save to database const postId = await this.saveBlogPost(blogContent, request) // Step 5: Generate related content suggestions await this.generateRelatedContentSuggestions(postId, request.topic) return { success: true, postId, content: blogContent.content, seoData: workflowResult } } catch (error) { console.error('‚ùå Blog AI generation failed:', error) return { success: false, errors: [error instanceof Error ? error.message : 'Unknown error'] } } } /** * Bulk generate blog posts from topic list */ async generateBulkBlogPosts(topics: string[]): Promise<BlogContentResult[]> { console.log(`üöÄ Starting bulk blog post generation for ${topics.length} topics`) const results: BlogContentResult[] = [] for (const topic of topics) { try { // Add delay to avoid rate limiting await new Promise(resolve => setTimeout(resolve, 2000)) const result = await this.generateBlogPost({ topic, publishImmediately: false }) results.push(result) if (result.success) { console.log(`‚úÖ Successfully generated: ${topic}`) } else { console.error(`‚ùå Failed to generate: ${topic}`, result.errors) } } catch (error) { console.error(`‚ùå Error generating ${topic}:`, error) results.push({ success: false, errors: [error instanceof Error ? error.message : 'Unknown error'] }) } } return results } /** * Generate content calendar */ async generateContentCalendar(months: number = 3): Promise<any[]> { console.log(`üìÖ Generating ${months}-month content calendar`) const calendarTask = new Task({ description: 'Generate SEO content calendar', prompt: `Use seo-content-planner to create a ${months}-month content calendar for a forex broker review blog. Topics to cover: - Forex trading basics and education - Broker reviews and comparisons - Market analysis and insights - Trading strategies and tips - Regulatory updates and compliance - Technology and platform reviews - Risk management and psychology For each month, provide: - 4-6 blog post topics - Target keywords - Content type (educational, review, analysis, news) - Priority level - Estimated word count - Target publish date - Internal linking opportunities Format as a structured calendar with strategic topic clustering.`, subagent_type: 'seo-content-planner' }) const calendarResult = await calendarTask.execute() return calendarResult.data?.calendar || [] } /** * Optimize existing blog post */ async optimizeExistingBlogPost(postId: string): Promise<BlogContentResult> { try { console.log(`üîç Optimizing existing blog post: ${postId}`) // Get existing post data const { data: post, error } = await supabase .from('blog_posts') .select('*') .eq('id', postId) .single() if (error) { return { success: false, errors: [error.message] } } // Execute improvement workflow const improvementResult = await this.seoWorkflow.executeImprovement(postId, 'refresh') if (!improvementResult.success) { return { success: false, errors: improvementResult.errors } } // Update post with optimizations await this.updateBlogPostOptimizations(postId, improvementResult) return { success: true, postId, seoData: improvementResult } } catch (error) { console.error('‚ùå Blog post optimization failed:', error) return { success: false, errors: [error instanceof Error ? error.message : 'Unknown error'] } } } /** * Generate blog post ideas based on trends */ async generateTrendBasedIdeas(): Promise<string[]> { console.log('üìà Generating trend-based blog post ideas') const researchTask = new Task({ description: 'Trend research for blog ideas', prompt: `Use search-specialist to research current forex trading trends and generate blog post ideas. Research: - Recent forex market trends - Popular trading strategies - Regulatory changes - Technology advancements - Market volatility patterns - Trader sentiment analysis - Economic indicators affecting forex Generate 10-15 trending blog post ideas with: - Compelling titles - Target keywords - Search intent - Content angle - Priority level Focus on timely, relevant topics that would interest forex traders.`, subagent_type: 'search-specialist' }) const researchResult = await researchTask.execute() return researchResult.data?.ideas || [] } /** * Content performance analysis */ async analyzeContentPerformance(postId: string): Promise<any> { console.log(`üìä Analyzing content performance for: ${postId}`) const auditTask = new Task({ description: 'Content performance analysis', prompt: `Use seo-content-auditor to analyze performance of blog post ID "${postId}" and provide optimization recommendations. Analyze: - Content engagement metrics - SEO performance indicators - User behavior signals - Keyword ranking potential - Content gap opportunities - Improvement recommendations Provide actionable insights for content enhancement.`, subagent_type: 'seo-content-auditor' }) const auditResult = await auditTask.execute() return auditResult } /** * Private helper methods */ private async getCategoryInfo(categoryId?: string) { if (!categoryId) return null const { data: category, error } = await supabase .from('blog_categories') .select('*') .eq('id', categoryId) .single() return error ? null : category } private async getTagInfo(tagIds?: string[]) { if (!tagIds || tagIds.length === 0) return [] const { data: tags, error } = await supabase .from('blog_tags') .select('*') .in('id', tagIds) return error ? [] : tags } private async formatBlogContent(workflowResult: any, request: BlogContentRequest) { // Extract content from workflow result const content = workflowResult.content?.content || '' const metadata = workflowResult.metaTags || {} return { title: metadata.title || request.topic, content: content, excerpt: metadata.description || '', meta_title: metadata.title || '', meta_description: metadata.description || '', seo_keywords: metadata.keywords || '', reading_time: this.calculateReadingTime(content), featured: request.featured || false, status: 'published', author_id: request.authorId || 'system' } } private async saveBlogPost(blogContent: any, request: BlogContentRequest): Promise<string> { const { data: post, error } = await supabase .from('blog_posts') .insert([{ ...blogContent, slug: this.generateSlug(blogContent.title), published_at: request.publishImmediately ? new Date().toISOString() : null }]) .select() .single() if (error) { throw new Error(`Failed to save blog post: ${error.message}`) } // Add categories and tags if specified if (request.categoryId) { await supabase .from('blog_post_categories') .insert([{ post_id: post.id, category_id: request.categoryId }]) } if (request.tags && request.tags.length > 0) { const tagInserts = request.tags.map(tagId => ({ post_id: post.id, tag_id: tagId })) await supabase .from('blog_post_tags') .insert(tagInserts) } return post.id } private async generateRelatedContentSuggestions(postId: string, topic: string) { const task = new Task({ description: 'Generate related content suggestions', prompt: `Generate 5-7 related blog post topics for "${topic}" that would be good for internal linking and content clustering. For each suggestion, provide: - Topic title - Target keywords - Content angle - Relationship to main topic - Priority level Focus on topics that would create a comprehensive content cluster.`, subagent_type: 'seo-content-planner' }) const result = await task.execute() // Save suggestions for future content planning await supabase .from('content_suggestions') .insert([{ post_id: postId, suggestions: result.data?.suggestions || [], created_at: new Date().toISOString() }]) } private async updateBlogPostOptimizations(postId: string, improvements: any) { const updates: any = {} if (improvements.metaTags) { updates.meta_title = improvements.metaTags.title updates.meta_description = improvements.metaTags.description updates.seo_keywords = improvements.metaTags.keywords } if (improvements.structuredData) { updates.structured_data = improvements.structuredData } updates.updated_at = new Date().toISOString() await supabase .from('blog_posts') .update(updates) .eq('id', postId) } private calculateReadingTime(content: string): number { const wordsPerMinute = 200 const wordCount = content.split(/\s+/).length return Math.ceil(wordCount / wordsPerMinute) } private generateSlug(title: string): string { return title .toLowerCase() .replace(/[^\w\s-]/g, '') .replace(/\s+/g, '-') .replace(/-+/g, '-') .trim() } } export default BlogAIAgentIntegration