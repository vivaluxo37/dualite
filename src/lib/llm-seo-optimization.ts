// LLM SEO Optimization Engine for BrokerAnalysis Blog // Implements On-Page LLM SEO principles for AI-friendly content export interface LLMEntity { name: string; type: 'tool' | 'company' | 'person' | 'technology' | 'platform' | 'regulator' | 'indicator' | 'strategy'; context: string; confidence: number; } export interface FAQItem { question: string; answer: string; context: string; } export interface SpeakableSection { text: string; cssSelector?: string; xpath?: string; wordCount: number; } export interface LLMOptimizationResult { optimizedContent: string; entities: LLMEntity[]; faqs: FAQItem[]; speakableSections: SpeakableSection[]; keyTakeaways: string[]; tableOfContents: TOCItem[]; internalLinks: InternalLink[]; schemaMarkup: SchemaMarkup; } export interface TOCItem { level: number; text: string; anchor: string; } export interface InternalLink { url: string; anchorText: string; context: string; relevanceScore: number; } export interface SchemaMarkup { faq: any[]; speakable: any; article: any; breadcrumb: any; } // Forex trading specific entity dictionaries const FOREX_ENTITIES = { regulators: [ 'FCA', 'CySEC', 'ASIC', 'FINMA', 'BaFin', 'SEC', 'CFTC', 'IIROC', 'FSA', 'MAS' ], platforms: [ 'MetaTrader 4', 'MetaTrader 5', 'cTrader', 'NinjaTrader', 'TradingView', 'Thinkorswim', 'WebTrader', 'Mobile App' ], tools: [ 'Economic Calendar', 'Pip Calculator', 'Margin Calculator', 'Profit Calculator', 'Currency Converter', 'Volatility Calculator', 'Correlation Matrix' ], indicators: [ 'RSI', 'MACD', 'Moving Average', 'Bollinger Bands', 'Stochastic', 'ATR', 'Fibonacci Retracement', 'Ichimoku Cloud', 'Parabolic SAR' ], brokers: [ 'IG Markets', 'Forex.com', 'OANDA', 'TD Ameritrade', 'Interactive Brokers', 'Saxo Bank', 'CMC Markets', 'Pepperstone', 'IC Markets' ], strategies: [ 'Scalping', 'Day Trading', 'Swing Trading', 'Position Trading', 'Carry Trade', 'Breakout Trading', 'Range Trading', 'Trend Following', 'Mean Reversion' ] }; export class LLMSEOOptimizer { private entityRegex: Map<string, RegExp[]> = new Map(); constructor() { this.initializeEntityRegex(); } private initializeEntityRegex() { // Compile regex patterns for entity detection Object.entries(FOREX_ENTITIES).forEach(([type, entities]) => { this.entityRegex.set(type, entities.map(entity => new RegExp(`\\b${entity.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi') )); }); } /** * Extract entities from content */ extractEntities(content: string): LLMEntity[] { const entities: LLMEntity[] = []; this.entityRegex.forEach((patterns, type) => { patterns.forEach(pattern => { const matches = content.match(pattern); if (matches) { matches.forEach(match => { const context = this.getEntityContext(content, match); entities.push({ name: match, type: type as any, context, confidence: this.calculateEntityConfidence(match, context) }); }); } }); }); // Remove duplicates and sort by confidence return entities .filter((entity, index, self) => index === self.findIndex(e => e.name.toLowerCase() === entity.name.toLowerCase()) ) .sort((a, b) => b.confidence - a.confidence); } /** * Get context around entity mention */ private getEntityContext(content: string, entity: string): string { const index = content.indexOf(entity); const start = Math.max(0, index - 100); const end = Math.min(content.length, index + entity.length + 100); return content.substring(start, end).trim(); } /** * Calculate confidence score for entity */ private calculateEntityConfidence(entity: string, context: string): number { let score = 0.5; // Base confidence // Boost score based on context keywords const boostKeywords = { regulators: ['regulated', 'license', 'compliance', 'authority'], platforms: ['platform', 'software', 'trading', 'interface'], tools: ['tool', 'calculator', 'analysis', 'chart'], indicators: ['indicator', 'signal', 'technical', 'chart'], brokers: ['broker', 'dealer', 'platform', 'account'], strategies: ['strategy', 'system', 'method', 'approach'] }; Object.entries(boostKeywords).forEach(([type, keywords]) => { if (context.toLowerCase().includes(type) || keywords.some(keyword => context.toLowerCase().includes(keyword))) { score += 0.2; } }); return Math.min(score, 1.0); } /** * Generate FAQ items from content */ generateFAQs(content: string, title: string): FAQItem[] { const faqs: FAQItem[] = []; // Extract questions from headings const headingQuestions = this.extractHeadingQuestions(content); faqs.push(...headingQuestions); // Generate conceptual questions const conceptualQuestions = this.generateConceptualQuestions(content, title); faqs.push(...conceptualQuestions); // Extract how-to questions const howToQuestions = this.extractHowToQuestions(content); faqs.push(...howToQuestions); return faqs.slice(0, 10); // Limit to top 10 FAQs } /** * Extract questions from headings */ private extractHeadingQuestions(content: string): FAQItem[] { const faqs: FAQItem[] = []; const headingRegex = /^#{2,4}\s*(.*\?)$/gm; let match; while ((match = headingRegex.exec(content)) !== null) { const question = match[1]; const answer = this.extractAnswerForQuestion(content, match.index); if (answer) { faqs.push({ question, answer: answer.substring(0, 300) + (answer.length > 300 ? '...' : ''), context: 'heading' }); } } return faqs; } /** * Generate conceptual questions from content */ private generateConceptualQuestions(content: string, title: string): FAQItem[] { const faqs: FAQItem[] = []; const keyPhrases = this.extractKeyPhrases(content); // Generate what/why/how questions const questionTemplates = [ 'What is {phrase}?', 'Why is {phrase} important?', 'How does {phrase} work?', 'When should you use {phrase}?', 'What are the benefits of {phrase}?' ]; keyPhrases.slice(0, 5).forEach(phrase => { const template = questionTemplates[Math.floor(Math.random() * questionTemplates.length)]; const question = template.replace('{phrase}', phrase); const answer = this.generateAnswerForConceptualQuestion(phrase, content); faqs.push({ question, answer: answer.substring(0, 250) + (answer.length > 250 ? '...' : ''), context: 'conceptual' }); }); return faqs; } /** * Extract key phrases from content */ private extractKeyPhrases(content: string): string[] { // Simple key phrase extraction based on capitalization and frequency const phrases = content .match(/\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b/g) || [] .filter(phrase => phrase.length > 3 && phrase.length < 50); // Return unique phrases return Array.from(new Set(phrases)); } /** * Generate answer for conceptual question */ private generateAnswerForConceptualQuestion(phrase: string, content: string): string { const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0); const relevantSentences = sentences.filter(sentence => sentence.toLowerCase().includes(phrase.toLowerCase()) ); if (relevantSentences.length > 0) { return relevantSentences[0].trim() + '.'; } return `${phrase} is an important concept in forex trading that helps traders make informed decisions.`; } /** * Extract how-to questions from content */ private extractHowToQuestions(content: string): FAQItem[] { const faqs: FAQItem[] = []; const howToRegex = /\b(how to|steps to|ways to|guide to)\s+([^.!?]+)/gi; let match; while ((match = howToRegex.exec(content)) !== null) { const question = `How to ${match[2]}?`; const answer = this.extractAnswerForQuestion(content, match.index); faqs.push({ question, answer: answer.substring(0, 250) + (answer.length > 250 ? '...' : ''), context: 'how-to' }); } return faqs; } /** * Extract answer for a specific question */ private extractAnswerForQuestion(content: string, questionIndex: number): string { const afterQuestion = content.substring(questionIndex); const sentences = afterQuestion.split(/[.!?]+/); // Return the first few sentences after the question return sentences .slice(1, 4) .filter(s => s.trim().length > 20) .join('. ') .trim(); } /** * Identify speakable sections for voice search */ identifySpeakableSections(content: string): SpeakableSection[] { const sections: SpeakableSection[] = []; // Extract introduction paragraph const introMatch = content.match(/^#{1}[^#]+?\n\n([^#\n]+)/); if (introMatch) { sections.push({ text: introMatch[1].trim(), wordCount: introMatch[1].trim().split(/\s+/).length }); } // Extract key takeaways or conclusion sections const conclusionRegex = /#{2,3}\s*(?:Key Takeaways|Conclusion|Summary|Final Thoughts)\s*\n\n([^#\n]+)/gi; let match; while ((match = conclusionRegex.exec(content)) !== null) { sections.push({ text: match[1].trim(), wordCount: match[1].trim().split(/\s+/).length }); } // Extract short, informative paragraphs const paragraphs = content.split(/\n\n+/).filter(p => p.trim().length > 50 && p.trim().length < 200 && !p.startsWith('#') ); paragraphs.slice(0, 3).forEach(paragraph => { const wordCount = paragraph.trim().split(/\s+/).length; if (wordCount >= 15 && wordCount <= 40) { sections.push({ text: paragraph.trim(), wordCount }); } }); return sections; } /** * Generate key takeaways Q&A block */ generateKeyTakeaways(content: string, title: string): string[] { const takeaways: string[] = []; // Extract main points from the content const mainPoints = this.extractMainPoints(content); // Generate Q&A pairs mainPoints.slice(0, 5).forEach((point, index) => { const questions = [ `What is the most important thing to know about ${title}?`, `What are the key benefits of ${title}?`, `How does ${title} help forex traders?`, `What should traders remember about ${title}?`, `Why is ${title} essential for trading success?` ]; takeaways.push(`**Q: ${questions[index]}**\nA: ${point}`); }); return takeaways; } /** * Extract main points from content */ private extractMainPoints(content: string): string[] { // Look for bold text, list items, and strong statements const points: string[] = []; // Extract bold statements const boldRegex = /\*\*([^*]+)\*\*/g; let match; while ((match = boldRegex.exec(content)) !== null) { if (match[1].length > 10 && match[1].length < 100) { points.push(match[1]); } } // Extract list items const listRegex = /^\s*[-*+]\s+([^\n]+)/gm; while ((match = listRegex.exec(content)) !== null) { if (match[1].length > 10 && match[1].length < 100) { points.push(match[1]); } } // Extract first sentences of paragraphs const paragraphs = content.split(/\n\n+/).filter(p => p.trim().length > 0 && !p.startsWith('#')); paragraphs.slice(0, 3).forEach(paragraph => { const firstSentence = paragraph.split(/[.!?]+/)[0]; if (firstSentence.length > 20 && firstSentence.length < 100) { points.push(firstSentence.trim()); } }); return Array.from(new Set(points)).slice(0, 10); } /** * Convert headings to question format */ convertHeadingsToQuestions(content: string): string { // Convert H2 and H3 headings to questions where appropriate return content .replace(/^#{2}\s+([^?]+)$/gm, (match, heading) => { if (this.shouldBeQuestion(heading)) { return `## ${this.headingToQuestion(heading)}`; } return match; }) .replace(/^#{3}\s+([^?]+)$/gm, (match, heading) => { if (this.shouldBeQuestion(heading)) { return `### ${this.headingToQuestion(heading)}`; } return match; }); } /** * Determine if a heading should be converted to a question */ private shouldBeQuestion(heading: string): boolean { const questionWords = ['how', 'what', 'why', 'when', 'where', 'which', 'who']; const nonQuestionPatterns = [ /introduction/i, /conclusion/i, /summary/i, /overview/i, /about/i, /example/i, /case study/i ]; const headingLower = heading.toLowerCase(); // Check if it already contains question words if (questionWords.some(word => headingLower.includes(word))) { return true; } // Check if it's not a non-question pattern return !nonQuestionPatterns.some(pattern => pattern.test(heading)); } /** * Convert heading to question format */ private headingToQuestion(heading: string): string { const questionTemplates = [ 'How to {heading}?', 'What is {heading}?', 'Why {heading}?', 'When should you {heading}?', 'Where can you {heading}?', 'Which {heading} is best?', 'Who should {heading}?' ]; const cleanHeading = heading.replace(/^the\s+/i, '').trim(); // Choose appropriate template based on heading content if (cleanHeading.toLowerCase().includes('understand') || cleanHeading.toLowerCase().includes('learn')) { return `What is ${cleanHeading}?`; } if (cleanHeading.toLowerCase().includes('use') || cleanHeading.toLowerCase().includes('implement') || cleanHeading.toLowerCase().includes('apply')) { return `How to ${cleanHeading}?`; } // Default to "What is" template return `What is ${cleanHeading}?`; } /** * Generate table of contents */ generateTableOfContents(content: string): TOCItem[] { const toc: TOCItem[] = []; const headingRegex = /^(#{2,4})\s+(.+)$/gm; let match; while ((match = headingRegex.exec(content)) !== null) { const level = match[1].length; const text = match[2].replace(/\*\*([^*]+)\*\*/g, '$1'); // Remove markdown const anchor = this.generateAnchor(text); toc.push({ level, text, anchor }); } return toc; } /** * Generate anchor for TOC */ private generateAnchor(text: string): string { return text .toLowerCase() .replace(/[^\w\s-]/g, '') .replace(/\s+/g, '-') .replace(/-+/g, '-') .trim(); } /** * Enhance content with entity-rich sentences */ enhanceContentWithEntities(content: string, entities: LLMEntity[]): string { const lines = content.split('\n'); let enhancedContent = ''; lines.forEach((line, index) => { // Skip headings and code blocks if (line.startsWith('#') || line.startsWith('```')) { enhancedContent += line + '\n'; return; } // Enhance first sentence of paragraphs if (line.trim().length > 0 && (index === 0 || lines[index - 1].trim() === '')) { const enhancedLine = this.enhanceSentenceWithEntities(line, entities); enhancedContent += enhancedLine + '\n'; } else { enhancedContent += line + '\n'; } }); return enhancedContent; } /** * Enhance individual sentence with entities */ private enhanceSentenceWithEntities(sentence: string, entities: LLMEntity[]): string { // Find relevant entities for this sentence const relevantEntities = entities .filter(entity => entity.confidence > 0.7) .slice(0, 3); if (relevantEntities.length === 0) { return sentence; } // Insert entities naturally into the sentence let enhancedSentence = sentence; relevantEntities.forEach(entity => { if (!enhancedSentence.toLowerCase().includes(entity.name.toLowerCase())) { // Find a good place to insert the entity enhancedSentence = this.insertEntityIntoSentence(enhancedSentence, entity); } }); return enhancedSentence; } /** * Insert entity into sentence naturally */ private insertEntityIntoSentence(sentence: string, entity: LLMEntity): string { // Simple insertion logic - insert after first comma or at the beginning const commaIndex = sentence.indexOf(','); if (commaIndex > 0 && commaIndex < sentence.length - 10) { return sentence.substring(0, commaIndex + 1) + ` including ${entity.name},` + sentence.substring(commaIndex + 1); } // Insert at the beginning for short sentences if (sentence.length < 100) { return `Using ${entity.name}, ${sentence.charAt(0).toLowerCase() + sentence.slice(1)}`; } return sentence; } /** * Main optimization method */ async optimizeContent(content: string, title: string, relatedArticles: Array<{title: string, url: string}> = []): Promise<LLMOptimizationResult> { // Step 1: Extract entities const entities = this.extractEntities(content); // Step 2: Generate FAQs const faqs = this.generateFAQs(content, title); // Step 3: Identify speakable sections const speakableSections = this.identifySpeakableSections(content); // Step 4: Generate key takeaways const keyTakeaways = this.generateKeyTakeaways(content, title); // Step 5: Convert headings to questions let optimizedContent = this.convertHeadingsToQuestions(content); // Step 6: Enhance with entities optimizedContent = this.enhanceContentWithEntities(optimizedContent, entities); // Step 7: Generate table of contents const tableOfContents = this.generateTableOfContents(optimizedContent); // Step 8: Generate internal links const internalLinks = this.generateInternalLinks(content, relatedArticles); // Step 9: Generate schema markup (placeholder - will be implemented in schema generator) const schemaMarkup = { faq: [], speakable: {}, article: {}, breadcrumb: {} }; return { optimizedContent, entities, faqs, speakableSections, keyTakeaways, tableOfContents, internalLinks, schemaMarkup }; } /** * Generate internal links to related articles */ private generateInternalLinks(content: string, relatedArticles: Array<{title: string, url: string}>): InternalLink[] { const links: InternalLink[] = []; relatedArticles.slice(0, 3).forEach(article => { links.push({ url: article.url, anchorText: article.title, context: 'related article', relevanceScore: 0.8 }); }); return links; } }