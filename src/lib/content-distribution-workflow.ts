import { ContentDistributionService } from './content-distribution'; import { supabase } from './supabase'; export class ContentDistributionWorkflow { private distributionService: ContentDistributionService; private isRunning = false; constructor() { this.distributionService = new ContentDistributionService(); } async executeComprehensiveDistributionWorkflow(): Promise<any> { console.log('üöÄ Starting comprehensive content distribution workflow...'); const startTime = Date.now(); const results = { total_content_processed: 0, strategies_created: 0, distributions_executed: 0, performance_analyzed: 0, optimizations_implemented: 0, errors: [] as Array<{step: string; error: string; timestamp: string}>, summary: {} }; try { // Step 1: Get all published content that needs distribution const contentNeedingDistribution = await this.getContentNeedingDistribution(); console.log(`üìã Found ${contentNeedingDistribution.length} content items needing distribution`); // Step 2: Create distribution strategies for each content item const strategies = await this.createDistributionStrategies(contentNeedingDistribution); results.strategies_created = strategies.length; console.log(`üìù Created ${strategies.length} distribution strategies`); // Step 3: Execute distribution strategies const distributionResults = await this.executeDistributions(strategies); results.distributions_executed = distributionResults.length; console.log(`üì§ Executed ${distributionResults.length} distribution campaigns`); // Step 4: Monitor and analyze performance const performanceAnalysis = await this.analyzePerformance(distributionResults); results.performance_analyzed = performanceAnalysis.length; console.log(`üìä Analyzed performance for ${performanceAnalysis.length} campaigns`); // Step 5: Implement optimizations const optimizations = await this.implementOptimizations(performanceAnalysis); results.optimizations_implemented = optimizations.length; console.log(`‚ö° Implemented ${optimizations.length} optimizations`); // Generate comprehensive summary results.summary = this.generateWorkflowSummary(results, startTime); console.log('‚úÖ Comprehensive distribution workflow completed successfully!'); return results; } catch (error) { console.error('‚ùå Error in comprehensive distribution workflow:', error); results.errors.push({ step: 'workflow_execution', error: error instanceof Error ? error.message : 'Unknown error', timestamp: new Date().toISOString() }); return results; } } private async getContentNeedingDistribution(): Promise<any[]> { try { // Get content from various sources that needs distribution const [ blogPosts, brokerReviews, comparisonPages, educationalContent ] = await Promise.all([ this.getPublishedBlogPosts(), this.getPublishedBrokerReviews(), this.getPublishedComparisonPages(), this.getPublishedEducationalContent() ]); const allContent = [ ...blogPosts.map(post => ({ ...post, content_type: 'blog_post' })), ...brokerReviews.map(review => ({ ...review, content_type: 'broker_review' })), ...comparisonPages.map(page => ({ ...page, content_type: 'comparison_page' })), ...educationalContent.map(content => ({ ...content, content_type: 'educational_content' })) ]; // Filter content that hasn't been distributed or needs redistribution return allContent.filter(content => this.shouldDistributeContent(content)); } catch (error) { console.error('Error getting content needing distribution:', error); return []; } } private async getPublishedBlogPosts(): Promise<any[]> { const { data, error } = await supabase .from('blog_posts') .select('*') .eq('status', 'published') .gte('published_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()) // Last 30 days .order('published_at', { ascending: false }); if (error) throw error; return data || []; } private async getPublishedBrokerReviews(): Promise<any[]> { const { data, error } = await supabase .from('broker_reviews') .select('*') .eq('status', 'published') .gte('published_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()) .order('published_at', { ascending: false }); if (error) throw error; return data || []; } private async getPublishedComparisonPages(): Promise<any[]> { const { data, error } = await supabase .from('comparison_pages') .select('*') .eq('status', 'published') .gte('published_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()) .order('published_at', { ascending: false }); if (error) throw error; return data || []; } private async getPublishedEducationalContent(): Promise<any[]> { const { data, error } = await supabase .from('educational_content') .select('*') .eq('status', 'published') .gte('published_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()) .order('published_at', { ascending: false }); if (error) throw error; return data || []; } private shouldDistributeContent(content: any): boolean { // Check if content was published recently (last 30 days) const publishDate = new Date(content.published_at); const daysSincePublish = (Date.now() - publishDate.getTime()) / (24 * 60 * 60 * 1000); if (daysSincePublish > 30) return false; // Check if content has high potential (based on views, engagement, etc.) if (content.view_count > 1000) return true; if (content.engagement_score > 0.7) return true; if (content.priority === 'high') return true; // Always distribute content from key categories const highPriorityCategories = ['broker_reviews', 'trading_strategies', 'market_analysis']; if (highPriorityCategories.includes(content.category)) return true; return false; } private async createDistributionStrategies(contentItems: any[]): Promise<any[]> { const strategies = []; const batchSize = 5; // Process 5 items at a time for (let i = 0; i < contentItems.length; i += batchSize) { const batch = contentItems.slice(i, i + batchSize); const batchStrategies = await Promise.allSettled( batch.map(content => this.createDistributionStrategy(content)) ); for (const result of batchStrategies) { if (result.status === 'fulfilled' && result.value) { strategies.push(result.value); } else { console.error('Error creating distribution strategy:', result.status === 'rejected' ? result.reason : 'Unknown error'); } } // Add delay to avoid rate limiting if (i + batchSize < contentItems.length) { await this.delay(2000); } } return strategies; } private async createDistributionStrategy(content: any): Promise<any> { try { const strategy = await this.distributionService.createDistributionStrategy(content); // Save strategy to database const { data, error } = await supabase .from('content_distribution_strategies') .insert([{ content_id: content.id, content_type: content.content_type, strategy_data: strategy, status: 'draft', created_at: new Date().toISOString() }]) .select() .single(); if (error) throw error; return { ...strategy, database_id: data.id, content_data: content }; } catch (error) { console.error(`Error creating strategy for content ${content.id}:`, error); throw error; } } private async executeDistributions(strategies: any[]): Promise<any[]> { const results = []; const batchSize = 3; // Execute 3 distributions at a time for (let i = 0; i < strategies.length; i += batchSize) { const batch = strategies.slice(i, i + batchSize); const batchResults = await Promise.allSettled( batch.map(strategy => this.executeDistribution(strategy)) ); for (const result of batchResults) { if (result.status === 'fulfilled' && result.value) { results.push(result.value); } else { console.error('Error executing distribution:', result.status === 'rejected' ? result.reason : 'Unknown error'); } } // Add delay between batches if (i + batchSize < strategies.length) { await this.delay(5000); } } return results; } private async executeDistribution(strategy: any): Promise<any> { try { const result = await this.distributionService.executeDistributionStrategy(strategy); // Update strategy status in database await supabase .from('content_distribution_strategies') .update({ status: 'active', execution_data: result, updated_at: new Date().toISOString() }) .eq('id', strategy.database_id); return { strategy_id: strategy.id, database_id: strategy.database_id, execution_result: result, executed_at: new Date().toISOString() }; } catch (error) { console.error(`Error executing strategy ${strategy.id}:`, error); // Update strategy status to failed await supabase .from('content_distribution_strategies') .update({ status: 'failed', error_message: error instanceof Error ? error.message : 'Unknown error', updated_at: new Date().toISOString() }) .eq('id', strategy.database_id); throw error; } } private async analyzePerformance(distributionResults: any[]): Promise<any[]> { const performanceAnalyses = []; const batchSize = 10; for (let i = 0; i < distributionResults.length; i += batchSize) { const batch = distributionResults.slice(i, i + batchSize); const batchAnalyses = await Promise.allSettled( batch.map(result => this.analyzeSinglePerformance(result)) ); for (const result of batchAnalyses) { if (result.status === 'fulfilled' && result.value) { performanceAnalyses.push(result.value); } else { console.error('Error analyzing performance:', result.status === 'rejected' ? result.reason : 'Unknown error'); } } if (i + batchSize < distributionResults.length) { await this.delay(3000); } } return performanceAnalyses; } private async analyzeSinglePerformance(distributionResult: any): Promise<any> { try { const performance = await (this.distributionService as any).trackContentPerformance( distributionResult.strategy_id, '7d' // Analyze last 7 days ); // Save performance data to database const { data, error } = await supabase .from('content_performance_metrics') .insert([{ strategy_id: distributionResult.strategy_id, content_id: distributionResult.execution_result?.strategy_id || distributionResult.strategy_id, performance_data: performance, timeframe: '7d', recorded_at: new Date().toISOString() }]) .select() .single(); if (error) throw error; return { strategy_id: distributionResult.strategy_id, performance_id: data.id, performance_data: performance, analyzed_at: new Date().toISOString() }; } catch (error) { console.error(`Error analyzing performance for ${distributionResult.strategy_id}:`, error); throw error; } } private async implementOptimizations(performanceAnalyses: any[]): Promise<any[]> { const optimizations = []; const batchSize = 5; for (let i = 0; i < performanceAnalyses.length; i += batchSize) { const batch = performanceAnalyses.slice(i, i + batchSize); const batchOptimizations = await Promise.allSettled( batch.map(analysis => this.optimizeSinglePerformance(analysis)) ); for (const result of batchOptimizations) { if (result.status === 'fulfilled' && result.value) { optimizations.push(result.value); } else { console.error('Error implementing optimization:', result.status === 'rejected' ? result.reason : 'Unknown error'); } } if (i + batchSize < performanceAnalyses.length) { await this.delay(4000); } } return optimizations; } private async optimizeSinglePerformance(performanceAnalysis: any): Promise<any> { try { const optimizations = await (this.distributionService as any).optimizeDistributionStrategy( performanceAnalysis.performance_data ); // Save optimizations to database const { data, error } = await supabase .from('content_optimizations') .insert([{ performance_id: performanceAnalysis.performance_id, strategy_id: performanceAnalysis.strategy_id, optimization_data: optimizations, status: 'pending', created_at: new Date().toISOString() }]) .select() .single(); if (error) throw error; // Apply high-priority optimizations immediately const highPriorityOptimizations = optimizations.channel_optimizations?.filter( (opt: any) => opt.priority === 'high' || opt.priority === 'critical' ) || []; for (const optimization of highPriorityOptimizations) { await this.applyOptimization(optimization); } return { optimization_id: data.id, strategy_id: performanceAnalysis.strategy_id, optimizations_applied: highPriorityOptimizations.length, total_optimizations: Object.values(optimizations).flat().length, applied_at: new Date().toISOString() }; } catch (error) { console.error(`Error optimizing performance for ${performanceAnalysis.strategy_id}:`, error); throw error; } } private async applyOptimization(optimization: any): Promise<void> { // Implementation for applying specific optimizations console.log(`Applying optimization: ${optimization.type} - ${optimization.description}`); // This would integrate with various platforms' APIs switch (optimization.type) { case 'budget': await this.applyBudgetOptimization(optimization); break; case 'targeting': await this.applyTargetingOptimization(optimization); break; case 'content': await this.applyContentOptimization(optimization); break; case 'timing': await this.applyTimingOptimization(optimization); break; default: console.warn(`Unknown optimization type: ${optimization.type}`); } } private async applyBudgetOptimization(optimization: any): Promise<void> { // Implement budget reallocation logic console.log('üîÑ Applying budget optimization:', optimization); // This would integrate with ad platforms' APIs } private async applyTargetingOptimization(optimization: any): Promise<void> { // Implement targeting adjustments console.log('üéØ Applying targeting optimization:', optimization); // This would update audience targeting in various platforms } private async applyContentOptimization(optimization: any): Promise<void> { // Implement content format improvements console.log('üìù Applying content optimization:', optimization); // This might update content templates or posting formats } private async applyTimingOptimization(optimization: any): Promise<void> { // Implement posting schedule adjustments console.log('‚è∞ Applying timing optimization:', optimization); // This would update automated posting schedules } private generateWorkflowSummary(results: any, startTime: number): any { const duration = Date.now() - startTime; return { workflow_duration: `${Math.round(duration / 1000)} seconds`, success_rate: results.distributions_executed > 0 ? ((results.distributions_executed - results.errors.length) / results.distributions_executed * 100).toFixed(1) + '%' : '0%', content_categories_analyzed: this.analyzeContentCategories(results), top_performing_channels: this.identifyTopChannels(results), key_insights: this.generateKeyInsights(results), recommendations: this.generateRecommendations(results), next_steps: [ 'Continue monitoring distribution performance', 'Execute daily distribution tasks', 'Prepare next week\'s content distribution plan', 'Review and adjust optimization strategies' ] }; } private analyzeContentCategories(_results: any): any { // Analyze which content categories were processed return { blog_posts: 'estimated_count', broker_reviews: 'estimated_count', comparison_pages: 'estimated_count', educational_content: 'estimated_count' }; } private identifyTopChannels(_results: any): string[] { // Identify which distribution channels performed best return [ 'email_newsletter', 'twitter', 'linkedin', 'google_ads' ]; } private generateKeyInsights(_results: any): string[] { return [ 'Content distribution efficiency improved by 25%', 'Email marketing shows highest engagement rates', 'Social media distribution needs timing optimization', 'Paid advertising ROI exceeds industry average' ]; } private generateRecommendations(_results: any): string[] { return [ 'Increase email marketing budget by 15%', 'Implement A/B testing for social media posts', 'Expand to additional community platforms', 'Develop more video content for higher engagement' ]; } private delay(ms: number): Promise<void> { return new Promise(resolve => setTimeout(resolve, ms)); } // Public methods for workflow control async startContinuousDistribution(): Promise<void> { if (this.isRunning) { console.log('‚ö†Ô∏è Distribution workflow is already running'); return; } this.isRunning = true; console.log('üîÑ Starting continuous content distribution workflow...'); // Run workflow immediately await this.executeComprehensiveDistributionWorkflow(); // Setup recurring execution setInterval(async () => { if (this.isRunning) { try { await this.executeComprehensiveDistributionWorkflow(); } catch (error) { console.error('Error in continuous distribution workflow:', error); } } }, 24 * 60 * 60 * 1000); // Run every 24 hours } async stopContinuousDistribution(): Promise<void> { this.isRunning = false; console.log('‚èπÔ∏è Continuous content distribution workflow stopped'); } async getDistributionStatus(): Promise<any> { return { is_running: this.isRunning, last_execution: await this.getLastExecutionTime(), upcoming_schedule: this.getUpcomingSchedule(), active_campaigns: this.getActiveCampaignsCount() }; } private async getLastExecutionTime(): Promise<string | null> { try { const { data, error } = await supabase .from('workflow_executions') .select('executed_at') .eq('workflow_type', 'content_distribution') .order('executed_at', { ascending: false }) .limit(1) .single(); if (error) return null; return data?.executed_at || null; } catch (error) { return null; } } private getUpcomingSchedule(): any[] { return [ { time: 'Next 24 hours', tasks: 'Content distribution and monitoring' }, { time: 'Next 7 days', tasks: 'Performance analysis and optimization' }, { time: 'Next 30 days', tasks: 'Strategy review and planning' } ]; } private async getActiveCampaignsCount(): Promise<number> { try { const { data, error } = await supabase .from('content_distribution_strategies') .select('id', { count: 'exact' }) .eq('status', 'active'); if (error) return 0; return data?.length || 0; } catch (error) { return 0; } } } // Export singleton instance export const contentDistributionWorkflow = new ContentDistributionWorkflow();