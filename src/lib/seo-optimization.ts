// SEO Optimization Agents for meta tags, structured data, and featured snippets // This service optimizes generated content for search engines and rich results export interface SEOOptimization { id?: string; content_id: string; meta_title: string; meta_description: string; focus_keywords: string[]; header_structure: HeaderStructure[]; structured_data: StructuredData[]; featured_snippet_optimization: FeaturedSnippetOptimization; internal_links: InternalLink[]; readability_score: number; seo_score: number; optimization_applied: string[]; created_at: string; updated_at: string; } export interface HeaderStructure { level: number; text: string; keyword_included: boolean; word_count: number; suggestions: string[]; } export interface StructuredData { type: string; data: any; context: string; validation_status: 'valid' | 'invalid' | 'warning'; } export interface FeaturedSnippetOptimization { snippet_type: 'paragraph' | 'list' | 'table' | 'definition'; target_keyword: string; content: string; position_optimization: string[]; confidence_score: number; } export interface InternalLink { url: string; anchor_text: string; context: string; relevance_score: number; do_follow: boolean; } export interface TechnicalSEOAudit { page_speed_score: number; mobile_friendliness: number; core_web_vitals: { lcp: number; // Largest Contentful Paint fid: number; // First Input Delay cls: number; // Cumulative Layout Shift fcp: number; // First Contentful Paint ttfb: number; // Time to First Byte }; meta_tags_optimization: number; structured_data_score: number; internal_linking_score: number; content_quality_score: number; accessibility_score: number; security_score: number; recommendations: string[]; critical_issues: string[]; } export interface PageWideOptimization { page_type: 'home' | 'broker_profile' | 'brokers_list' | 'blog' | 'comparison' | 'guide'; technical_audit: TechnicalSEOAudit; optimization_strategy: string[]; implementation_priority: 'high' | 'medium' | 'low'; estimated_impact: 'significant' | 'moderate' | 'minimal'; timeline_weeks: number; } export interface SEOOptimizationRequest { content: string; title: string; content_type: string; target_keywords: string[]; broker_data: any; current_url?: string; include_structured_data: boolean; optimize_for_snippets: boolean; page_type?: 'home' | 'broker_profile' | 'brokers_list' | 'blog' | 'comparison' | 'guide'; mobile_optimization?: boolean; core_web_vitals?: boolean; technical_audit?: boolean; comprehensive_optimization?: boolean; } export class SEOOptimizationAgent { private supabaseProjectId: string; constructor(supabaseProjectId: string) { this.supabaseProjectId = supabaseProjectId; } async optimizeContent(request: SEOOptimizationRequest): Promise<SEOOptimization> { try { console.log(`Optimizing content for SEO: ${request.title}`); const startTime = Date.now(); // Step 1: Generate meta tags const metaOptimization = await this.generateMetaTags(request); // Step 2: Analyze and optimize header structure const headerStructure = await this.optimizeHeaderStructure(request.content, request.target_keywords); // Step 3: Generate structured data const structuredData = request.include_structured_data ? await this.generateStructuredData(request) : []; // Step 4: Optimize for featured snippets const featuredSnippet = request.optimize_for_snippets ? await this.optimizeForFeaturedSnippets(request) : null; // Step 5: Optimize internal linking const internalLinks = await this.optimizeInternalLinking(request); // Step 6: Calculate SEO and readability scores const scores = await this.calculateSEOScores(request, { metaOptimization, headerStructure, structuredData, featuredSnippet, internalLinks }); // Step 7: Compile final optimization const optimization: SEOOptimization = { content_id: 'mock_content_id', // Would be populated from actual content meta_title: metaOptimization.title, meta_description: metaOptimization.description, focus_keywords: request.target_keywords, header_structure: headerStructure, structured_data, featured_snippet_optimization: featuredSnippet || this.getDefaultFeaturedSnippet(), internal_links: internalLinks, readability_score: scores.readability, seo_score: scores.seo, optimization_applied: this.getOptimizationsApplied(request), created_at: new Date().toISOString(), updated_at: new Date().toISOString() }; // Save optimization to database const savedOptimization = await this.saveSEOOptimization(optimization); return savedOptimization; } catch (error) { console.error('Error optimizing content for SEO:', error); throw error; } } private async generateMetaTags(request: SEOOptimizationRequest): Promise<{ title: string; description: string }> { try { console.log('Generating meta tags'); // Generate meta title (50-60 characters) const metaTitle = this.generateMetaTitle(request.title, request.target_keywords, request.content_type); // Generate meta description (150-160 characters) const metaDescription = await this.generateMetaDescription(request, metaTitle); return { title: metaTitle, description: metaDescription }; } catch (error) { console.error('Error generating meta tags:', error); return { title: request.title.substring(0, 60), description: request.content.substring(0, 155) + '...' }; } } private generateMetaTitle(baseTitle: string, keywords: string[], contentType: string): string { const primaryKeyword = keywords[0] || ''; const templates = { review: `${baseTitle} Review - ${primaryKeyword} | Is it Worth It?`, comparison: `${baseTitle} vs Competitors - Best ${primaryKeyword} for 2024`, tutorial: `How to ${baseTitle} - Complete ${primaryKeyword} Tutorial`, guide: `The Ultimate Guide to ${baseTitle} - ${primaryKeyword} Explained`, news: `${baseTitle}: Latest Updates on ${primaryKeyword} - Market Analysis` }; let title = templates[contentType] || `${baseTitle} - ${primaryKeyword}`; // Ensure title length is optimal (50-60 characters) if (title.length > 60) { title = title.substring(0, 57) + '...'; } else if (title.length < 50) { // Add year if too short title += ' 2024'; } return title; } private async generateMetaDescription(request: SEOOptimizationRequest, metaTitle: string): Promise<string> { try { const primaryKeyword = request.target_keywords[0] || ''; // Extract key sentences from content that contain the primary keyword const sentences = request.content.split(/[.!?]+/).filter(s => s.trim().length > 0); const keywordSentences = sentences.filter(sentence => sentence.toLowerCase().includes(primaryKeyword.toLowerCase()) ); let description = ''; if (keywordSentences.length > 0) { // Use the most relevant sentence with the keyword description = keywordSentences[0].trim(); } else { // Use the first sentence if no keyword sentences found description = sentences[0]?.trim() || ''; } // Add call to action based on content type const ctas = { review: 'Read our comprehensive review to make an informed decision.', comparison: 'Compare features and find the best option for your needs.', tutorial: 'Learn step-by-step with our detailed tutorial.', guide: 'Discover everything you need to know in our complete guide.', news: 'Stay informed with the latest market analysis and updates.' }; const cta = ctas[request.content_type] || ctas.guide; // Combine description with CTA let fullDescription = `${description} ${cta}`; // Ensure optimal length (150-160 characters) if (fullDescription.length > 160) { fullDescription = fullDescription.substring(0, 157) + '...'; } else if (fullDescription.length < 150) { // Add more detail if too short fullDescription += ` Learn about ${primaryKeyword} and trading options.`; } return fullDescription; } catch (error) { console.error('Error generating meta description:', error); return request.content.substring(0, 155) + '...'; } } private async optimizeHeaderStructure(content: string, targetKeywords: string[]): Promise<HeaderStructure[]> { try { console.log('Optimizing header structure'); const headerRegex = /^(#{1,6})\s+(.+)$/gm; const headers: HeaderStructure[] = []; let match; while ((match = headerRegex.exec(content)) !== null) { const level = match[1].length; const text = match[2].trim(); const wordCount = text.split(/\s+/).length; // Check if target keywords are included in headers const keywordIncluded = targetKeywords.some(keyword => text.toLowerCase().includes(keyword.toLowerCase()) ); const suggestions = this.generateHeaderSuggestions(text, level, keywordIncluded, targetKeywords); headers.push({ level, text, keyword_included: keywordIncluded, word_count: wordCount, suggestions }); } // If no headers found, suggest adding them if (headers.length === 0) { headers.push({ level: 1, text: 'No headers found - consider adding H1, H2, H3 headers', keyword_included: false, word_count: 0, suggestions: ['Add H1 header with main keyword', 'Include H2 headers for main sections', 'Use H3 headers for subsections'] }); } return headers; } catch (error) { console.error('Error optimizing header structure:', error); return []; } } private generateHeaderSuggestions(text: string, level: number, keywordIncluded: boolean, targetKeywords: string[]): string[] { const suggestions: string[] = []; if (!keywordIncluded && level <= 2) { suggestions.push(`Consider including primary keyword: ${targetKeywords[0]}`); } if (text.length > 60) { suggestions.push('Header text is too long - consider shortening for better readability'); } if (text.length < 20) { suggestions.push('Header text is very short - consider adding more descriptive text'); } if (level === 1 && text.toLowerCase().includes('welcome') || text.toLowerCase().includes('introduction')) { suggestions.push('H1 should contain the main topic or keyword, not generic terms'); } return suggestions; } private async generateStructuredData(request: SEOOptimizationRequest): Promise<StructuredData[]> { try { console.log('Generating structured data'); const structuredData: StructuredData[] = []; // Article structured data const articleData = this.generateArticleStructuredData(request); structuredData.push(articleData); // Review structured data if content type is review if (request.content_type === 'review') { const reviewData = this.generateReviewStructuredData(request); structuredData.push(reviewData); } // Broker structured data const brokerData = this.generateBrokerStructuredData(request); structuredData.push(brokerData); // FAQ structured data if content has Q&A format if (request.content.includes('?') || request.content.includes('FAQ')) { const faqData = this.generateFAQStructuredData(request); structuredData.push(faqData); } return structuredData; } catch (error) { console.error('Error generating structured data:', error); return []; } } private generateArticleStructuredData(request: SEOOptimizationRequest): StructuredData { const wordCount = request.content.split(/\s+/).length; const readingTime = Math.ceil(wordCount / 200); return { type: 'Article', data: { '@context': 'https://schema.org', '@type': 'Article', 'headline': request.title, 'description': request.content.substring(0, 160) + '...', 'wordCount': wordCount, 'timeRequired': `PT${readingTime}M`, 'author': { '@type': 'Organization', 'name': 'Dualite Forex Broker Reviews' }, 'publisher': { '@type': 'Organization', 'name': 'BrokerAnalysis', 'logo': { '@type': 'ImageObject', 'url': 'https://brokeranalysis.com/logo.png' } }, 'datePublished': new Date().toISOString(), 'dateModified': new Date().toISOString(), 'inLanguage': 'en-US', 'isAccessibleForFree': true, 'keywords': request.target_keywords.join(', ') }, context: 'Main article structured data for SEO', validation_status: 'valid' }; } private generateReviewStructuredData(request: SEOOptimizationRequest): StructuredData { return { type: 'Review', data: { '@context': 'https://schema.org', '@type': 'Review', 'itemReviewed': { '@type': 'Organization', 'name': request.broker_data?.name || 'Forex Broker', 'sameAs': request.broker_data?.website || '' }, 'author': { '@type': 'Organization', 'name': 'Dualite Forex Broker Reviews' }, 'datePublished': new Date().toISOString(), 'reviewRating': { '@type': 'Rating', 'ratingValue': request.broker_data?.overall_rating || 4.0, 'bestRating': 5, 'worstRating': 1 }, 'name': request.title, 'reviewBody': request.content.substring(0, 500) + '...' }, context: 'Broker review structured data', validation_status: 'valid' }; } private generateBrokerStructuredData(request: SEOOptimizationRequest): StructuredData { return { type: 'FinancialService', data: { '@context': 'https://schema.org', '@type': 'FinancialService', 'name': request.broker_data?.name || 'Forex Broker', 'description': request.broker_data?.company_description || 'Online forex trading services', 'url': request.broker_data?.website || '', 'telephone': request.broker_data?.contact_info?.phone || '', 'address': { '@type': 'PostalAddress', 'addressCountry': request.broker_data?.headquarters?.country || '' }, 'serviceArea': { '@type': 'Country', 'name': 'Global' }, 'provider': { '@type': 'Organization', 'name': request.broker_data?.name || 'Forex Broker' } }, context: 'Financial service structured data for broker', validation_status: 'valid' }; } private generateFAQStructuredData(request: SEOOptimizationRequest): StructuredData { // Extract potential Q&A pairs from content const questions = this.extractFAQFromContent(request.content); const faqData = { '@context': 'https://schema.org', '@type': 'FAQPage', 'mainEntity': questions.map(qa => ({ '@type': 'Question', 'name': qa.question, 'acceptedAnswer': { '@type': 'Answer', 'text': qa.answer } })) }; return { type: 'FAQPage', data: faqData, context: 'FAQ structured data extracted from content', validation_status: questions.length > 0 ? 'valid' : 'warning' }; } private extractFAQFromContent(content: string): { question: string; answer: string }[] { const faqPairs: { question: string; answer: string }[] = []; // Look for question patterns const questionPatterns = [ /(?:What|How|When|Where|Why|Which|Who)\s+.*?\?/g, /(?:Is|Are|Can|Should|Do|Does)\s+.*?\?/g, /(?:^|\n)\s*[-*]\s*(.*?\?)\s*\n/g ]; for (const pattern of questionPatterns) { let match; while ((match = pattern.exec(content)) !== null) { const question = match[1] || match[0]; // Look for answer after the question (next few sentences) const questionIndex = content.indexOf(question); if (questionIndex !== -1) { const afterQuestion = content.substring(questionIndex + question.length); const sentences = afterQuestion.split(/[.!?]+/).filter(s => s.trim().length > 0); if (sentences.length > 0) { const answer = sentences[0].trim(); if (answer.length > 20 && answer.length < 300) { faqPairs.push({ question, answer }); } } } } } return faqPairs.slice(0, 5); // Limit to 5 FAQ pairs } private async optimizeForFeaturedSnippets(request: SEOOptimizationRequest): Promise<FeaturedSnippetOptimization> { try { console.log('Optimizing for featured snippets'); const primaryKeyword = request.target_keywords[0] || ''; // Determine best snippet type based on content analysis const snippetType = this.determineBestSnippetType(request.content, primaryKeyword); // Generate optimized snippet content const snippetContent = this.generateSnippetContent(request.content, primaryKeyword, snippetType); // Generate position optimization strategies const positionOptimization = this.generatePositionOptimization(snippetType, primaryKeyword); return { snippet_type: snippetType, target_keyword: primaryKeyword, content: snippetContent, position_optimization: positionOptimization, confidence_score: this.calculateSnippetConfidence(snippetContent, primaryKeyword) }; } catch (error) { console.error('Error optimizing for featured snippets:', error); return this.getDefaultFeaturedSnippet(); } } private determineBestSnippetType(content: string, keyword: string): 'paragraph' | 'list' | 'table' | 'definition' { const lowerContent = content.toLowerCase(); // Check for list patterns if (lowerContent.includes('following') || lowerContent.includes('steps') || lowerContent.match(/\d+\./) || lowerContent.includes('bullet points')) { return 'list'; } // Check for table patterns if (lowerContent.includes('comparison') || lowerContent.includes('table') || lowerContent.includes('versus') || lowerContent.includes('vs')) { return 'table'; } // Check for definition patterns if (keyword && (lowerContent.includes('is') || lowerContent.includes('refers to') || lowerContent.includes('means') || lowerContent.includes('defined as'))) { return 'definition'; } // Default to paragraph return 'paragraph'; } private generateSnippetContent(content: string, keyword: string, snippetType: string): string { const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0); switch (snippetType) { case 'paragraph': // Find the most comprehensive sentence containing the keyword const keywordSentences = sentences.filter(s => s.toLowerCase().includes(keyword.toLowerCase()) ); if (keywordSentences.length > 0) { // Return the longest keyword sentence return keywordSentences.reduce((longest, current) => current.length > longest.length ? current : longest ); } // Fallback to first sentence return sentences[0] || ''; case 'list': // Extract list items from content const listItems = this.extractListItems(content); return listItems.slice(0, 5).join('\n'); case 'table': // Create a simple comparison table return this.generateComparisonTable(content, keyword); case 'definition': // Find definition sentence const definitionPatterns = [ new RegExp(`${keyword}\\s+is\\s+([^.]*)`, 'i'), new RegExp(`${keyword}\\s+refers to\\s+([^.]*)`, 'i'), new RegExp(`${keyword}\\s+means\\s+([^.]*)`, 'i') ]; for (const pattern of definitionPatterns) { const match = content.match(pattern); if (match) { return match[1].trim(); } } return `${keyword} is a forex trading broker offering various financial services.`; default: return sentences[0] || ''; } } private extractListItems(content: string): string[] { const listItems: string[] = []; // Extract numbered lists const numberedItems = content.match(/\d+\.\s*([^\n]+)/g); if (numberedItems) { listItems.push(...numberedItems.map(item => item.replace(/^\d+\.\s*/, ''))); } // Extract bullet points const bulletItems = content.match(/[-*•]\s*([^\n]+)/g); if (bulletItems) { listItems.push(...bulletItems.map(item => item.replace(/^[-*•]\s*/, ''))); } return listItems; } private generateComparisonTable(content: string, keyword: string): string { // Simple table structure for broker comparison return ` Feature | ${keyword} | Industry Average --- | --- | --- Regulation | FCA, CySEC | FCA, ASIC Spreads | From 0.8 pips | From 1.0 pips Leverage | Up to 1:500 | Up to 1:30 Platforms | MT4, MT5, Web | MT4, MT5 Minimum Deposit | $100 | $250 `.trim(); } private generatePositionOptimization(snippetType: string, keyword: string): string[] { const optimizations = [ `Place the ${snippetType} snippet near the top of the content`, `Include the exact keyword "${keyword}" in the snippet`, `Ensure the snippet directly answers the search query`, `Keep the snippet concise and informative`, `Use clear formatting appropriate for the snippet type` ]; if (snippetType === 'list') { optimizations.push('Use numbered lists for step-by-step instructions'); optimizations.push('Use bullet points for feature lists'); } else if (snippetType === 'table') { optimizations.push('Include clear headers and structured data'); optimizations.push('Focus on comparison metrics'); } return optimizations; } private calculateSnippetConfidence(snippetContent: string, keyword: string): number { let confidence = 50; // Base confidence // Boost if keyword is included if (snippetContent.toLowerCase().includes(keyword.toLowerCase())) { confidence += 20; } // Boost based on content length if (snippetContent.length >= 50 && snippetContent.length <= 300) { confidence += 15; } // Boost for clear structure if (snippetContent.includes('|') || snippetContent.includes('\n')) { confidence += 10; } return Math.min(confidence, 100); } private getDefaultFeaturedSnippet(): FeaturedSnippetOptimization { return { snippet_type: 'paragraph', target_keyword: '', content: '', position_optimization: [], confidence_score: 0 }; } private async optimizeInternalLinking(request: SEOOptimizationRequest): Promise<InternalLink[]> { try { console.log('Optimizing internal linking'); const internalLinks: InternalLink[] = []; // Common internal linking opportunities for forex content const linkOpportunities = [ { keywords: ['trading platform', 'mt4', 'mt5', 'trading software'], url: '/trading-platforms', anchor: 'best forex trading platforms', relevance: 95 }, { keywords: ['regulation', 'license', 'fca', 'cysec', 'asic'], url: '/broker-regulation', anchor: 'forex broker regulation', relevance: 90 }, { keywords: ['demo account', 'practice account', 'paper trading'], url: '/demo-accounts', anchor: 'forex demo accounts', relevance: 85 }, { keywords: ['spread', 'commission', 'fees', 'trading costs'], url: '/trading-costs', anchor: 'forex trading costs', relevance: 80 }, { keywords: ['leverage', 'margin', 'risk management'], url: '/leverage-guide', anchor: 'forex leverage guide', relevance: 85 } ]; // Find linking opportunities in content for (const opportunity of linkOpportunities) { const foundKeywords = opportunity.keywords.filter(keyword => request.content.toLowerCase().includes(keyword.toLowerCase()) ); if (foundKeywords.length > 0) { internalLinks.push({ url: opportunity.url, anchor_text: opportunity.anchor, context: `Link to ${opportunity.anchor} for related information`, relevance_score: opportunity.relevance, do_follow: true }); } } // Add broker-specific links if broker data is available if (request.broker_data && request.broker_data.name) { internalLinks.push({ url: `/brokers/${request.broker_data.name.toLowerCase().replace(/\s+/g, '-')}`, anchor_text: `${request.broker_data.name} review`, context: 'Link to detailed broker review', relevance_score: 100, do_follow: true }); } return internalLinks.slice(0, 10); // Limit to 10 internal links } catch (error) { console.error('Error optimizing internal linking:', error); return []; } } private async calculateSEOScores(request: SEOOptimizationRequest, optimizationData: any): Promise<{ readability: number; seo: number }> { try { // Calculate readability score const readabilityScore = this.calculateReadabilityScore(request.content); // Calculate SEO score const seoScore = this.calculateSEOScore(request, optimizationData); return { readability: readabilityScore, seo: seoScore }; } catch (error) { console.error('Error calculating SEO scores:', error); return { readability: 50, seo: 50 }; } } private calculateReadabilityScore(content: string): number { const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0); const words = content.split(/\s+/).filter(w => w.length > 0); const avgWordsPerSentence = words.length / sentences.length; let score = 100; // Penalize for long sentences if (avgWordsPerSentence > 20) { score -= (avgWordsPerSentence - 20) * 2; } // Penalize for very short sentences if (avgWordsPerSentence < 10) { score -= (10 - avgWordsPerSentence) * 1; } // Check for paragraph length const paragraphs = content.split('\n\n').filter(p => p.trim().length > 0); const avgWordsPerParagraph = words.length / paragraphs.length; if (avgWordsPerParagraph > 150) { score -= 10; } return Math.max(Math.min(score, 100), 0); } private calculateSEOScore(request: SEOOptimizationRequest, optimizationData: any): number { let score = 0; // Meta tags optimization (20 points) if (optimizationData.metaOptimization.title.length >= 50 && optimizationData.metaOptimization.title.length <= 60) { score += 10; } if (optimizationData.metaOptimization.description.length >= 150 && optimizationData.metaOptimization.description.length <= 160) { score += 10; } // Header structure (20 points) const goodHeaders = optimizationData.headerStructure.filter(h => h.keyword_included && h.word_count >= 10 && h.word_count <= 60); score += Math.min(goodHeaders.length * 5, 20); // Structured data (15 points) score += Math.min(optimizationData.structuredData.length * 5, 15); // Featured snippet optimization (15 points) if (optimizationData.featuredSnippet && optimizationData.featuredSnippet.confidence_score > 70) { score += 15; } // Internal linking (15 points) score += Math.min(optimizationData.internalLinks.length * 3, 15); // Content length (10 points) const wordCount = request.content.split(/\s+/).length; if (wordCount >= 1000) { score += 10; } else if (wordCount >= 500) { score += 5; } // Keyword usage (5 points) const keywordCount = request.targetKeywords.reduce((count, keyword) => { return count + (request.content.toLowerCase().match(new RegExp(keyword.toLowerCase(), 'g')) || []).length; }, 0); if (keywordCount >= 3) { score += 5; } return Math.min(score, 100); } private getOptimizationsApplied(request: SEOOptimizationRequest): string[] { const optimizations = [ 'Meta tags optimization', 'Header structure analysis', 'Keyword optimization', 'Internal linking strategy' ]; if (request.include_structured_data) { optimizations.push('Structured data implementation'); } if (request.optimize_for_snippets) { optimizations.push('Featured snippet optimization'); } return optimizations; } private async saveSEOOptimization(optimization: SEOOptimization): Promise<SEOOptimization> { try { // This would use the mcp__supabase__execute_sql MCP tool console.log(`Saving SEO optimization for content`); // Mock implementation const savedOptimization = { id: `mock_seo_${Date.now()}`, ...optimization }; return savedOptimization; } catch (error) { console.error('Error saving SEO optimization:', error); throw error; } } async generateSEOReport(contentId: string): Promise<any> { try { // This would fetch SEO optimization data and generate comprehensive report console.log(`Generating SEO report for content: ${contentId}`); return { content_id: contentId, report_generated_at: new Date().toISOString(), seo_score: 85, readability_score: 78, recommendations: [ 'Add more internal links to related content', 'Include structured data for better rich snippets', 'Optimize images with alt text', 'Improve page loading speed' ], technical_seo: { meta_tags: 'Optimal', header_structure: 'Good', structured_data: 'Present', internal_links: 'Adequate' }, content_analysis: { word_count: 1250, keyword_density: '1.2%', readability_score: 78, featured_snippet_potential: 'High' } }; } catch (error) { console.error('Error generating SEO report:', error); return null; } } // Technical SEO Optimization Methods async performTechnicalSEOAudit(request: SEOOptimizationRequest): Promise<TechnicalSEOAudit> { try { console.log(`Performing technical SEO audit for: ${request.title}`); const audit: TechnicalSEOAudit = { page_speed_score: await this.analyzePageSpeed(request), mobile_friendliness: await this.analyzeMobileFriendliness(request), core_web_vitals: await this.analyzeCoreWebVitals(request), meta_tags_optimization: await this.analyzeMetaTagsOptimization(request), structured_data_score: await this.analyzeStructuredDataOptimization(request), internal_linking_score: await this.analyzeInternalLinking(request), content_quality_score: await this.analyzeContentQuality(request), accessibility_score: await this.analyzeAccessibility(request), security_score: await this.analyzeSecurity(request), recommendations: [], critical_issues: [] }; // Generate recommendations based on audit results audit.recommendations = this.generateTechnicalRecommendations(audit); audit.critical_issues = this.identifyCriticalIssues(audit); return audit; } catch (error) { console.error('Error performing technical SEO audit:', error); throw error; } } private async analyzePageSpeed(request: SEOOptimizationRequest): Promise<number> { try { let score = 70; // Base score // Content length impact const wordCount = request.content.split(/\s+/).length; if (wordCount > 2000) score -= 10; if (wordCount > 5000) score -= 15; // Image optimization simulation const imageReferences = (request.content.match(/!\[.*?\]\(.*?\)/g) || []).length; if (imageReferences > 5) score -= 5; // Code complexity simulation const codeBlocks = (request.content.match(/```[\s\S]*?```/g) || []).length; if (codeBlocks > 3) score -= 5; // External resources simulation const externalLinks = (request.content.match(/\[.*?\]\(https?:\/\/.*?\)/g) || []).length; if (externalLinks > 10) score -= 5; return Math.max(score, 0); } catch (error) { console.error('Error analyzing page speed:', error); return 50; } } private async analyzeMobileFriendliness(request: SEOOptimizationRequest): Promise<number> { try { let score = 85; // Base score // Content structure analysis const paragraphs = request.content.split('\n\n').filter(p => p.trim().length > 0); const longParagraphs = paragraphs.filter(p => p.split(/\s+/).length > 100).length; if (longParagraphs > paragraphs.length * 0.3) score -= 15; // Table complexity const tables = (request.content.match(/\|.*\|/g) || []).length; if (tables > 2) score -= 10; // Image optimization for mobile const images = (request.content.match(/!\[.*?\]\(.*?\)/g) || []).length; if (images > 5) score -= 8; // Readability for mobile const avgSentenceLength = request.content.split(/[.!?]+/).filter(s => s.trim().length > 0) .reduce((acc, sentence) => acc + sentence.split(/\s+/).length, 0) / request.content.split(/[.!?]+/).filter(s => s.trim().length > 0).length; if (avgSentenceLength > 20) score -= 10; return Math.max(score, 0); } catch (error) { console.error('Error analyzing mobile friendliness:', error); return 60; } } private async analyzeCoreWebVitals(request: SEOOptimizationRequest): Promise<{ lcp: number; fid: number; cls: number; fcp: number; ttfb: number; }> { try { // Simulated Core Web Vitals analysis based on content characteristics const contentSize = request.content.length; const imageCount = (request.content.match(/!\[.*?\]\(.*?\)/g) || []).length; const externalResourceCount = (request.content.match(/\[.*?\]\(https?:\/\/.*?\)/g) || []).length; return { lcp: Math.min(2.5 + (contentSize / 10000) + (imageCount * 0.3), 8.0), // Target < 2.5s fid: Math.min(80 + (externalResourceCount * 10), 300), // Target < 100ms cls: Math.min(0.05 + (imageCount * 0.02), 0.25), // Target < 0.1 fcp: Math.min(1.2 + (contentSize / 8000), 4.0), // Target < 1.8s ttfb: Math.min(0.4 + (externalResourceCount * 0.1), 1.5) // Target < 0.6s }; } catch (error) { console.error('Error analyzing Core Web Vitals:', error); return { lcp: 4.0, fid: 200, cls: 0.15, fcp: 2.5, ttfb: 1.0 }; } } private async analyzeMetaTagsOptimization(request: SEOOptimizationRequest): Promise<number> { try { let score = 0; // Title optimization if (request.title.length >= 50 && request.title.length <= 60) score += 25; if (request.target_keywords.some(keyword => request.title.toLowerCase().includes(keyword.toLowerCase()))) score += 25; // Meta description simulation const descriptionLength = request.content.substring(0, 160).length; if (descriptionLength >= 150 && descriptionLength <= 160) score += 25; if (request.target_keywords.some(keyword => request.content.toLowerCase().includes(keyword.toLowerCase()))) score += 25; return Math.min(score, 100); } catch (error) { console.error('Error analyzing meta tags optimization:', error); return 50; } } private async analyzeStructuredDataOptimization(request: SEOOptimizationRequest): Promise<number> { try { let score = 0; if (request.include_structured_data) { score += 40; // Base score for including structured data // Check for different schema types if (request.content_type === 'review') score += 20; if (request.broker_data) score += 20; if (request.content.includes('FAQ') || request.content.includes('?')) score += 20; } return Math.min(score, 100); } catch (error) { console.error('Error analyzing structured data optimization:', error); return 0; } } private async analyzeInternalLinking(request: SEOOptimizationRequest): Promise<number> { try { const internalLinks = (request.content.match(/\[.*?\]\(\/.*?\)/g) || []).length; const wordCount = request.content.split(/\s+/).length; // Ideal internal link density: 1-2 links per 500 words const optimalLinks = Math.max(1, Math.floor(wordCount / 500)); let score = 0; if (internalLinks >= optimalLinks * 0.8) score += 50; if (internalLinks <= optimalLinks * 1.5) score += 30; if (internalLinks > 0) score += 20; return Math.min(score, 100); } catch (error) { console.error('Error analyzing internal linking:', error); return 30; } } private async analyzeContentQuality(request: SEOOptimizationRequest): Promise<number> { try { let score = 50; // Base score // Content length const wordCount = request.content.split(/\s+/).length; if (wordCount >= 1000) score += 20; if (wordCount >= 2000) score += 10; // Readability const avgSentenceLength = request.content.split(/[.!?]+/).filter(s => s.trim().length > 0) .reduce((acc, sentence) => acc + sentence.split(/\s+/).length, 0) / request.content.split(/[.!?]+/).filter(s => s.trim().length > 0).length; if (avgSentenceLength >= 15 && avgSentenceLength <= 20) score += 20; // Keyword usage const keywordDensity = request.target_keywords.reduce((count, keyword) => { return count + (request.content.toLowerCase().match(new RegExp(keyword.toLowerCase(), 'g')) || []).length; }, 0) / wordCount * 100; if (keywordDensity >= 1 && keywordDensity <= 3) score += 10; // Structure const headers = (request.content.match(/^#{1,6}\s+.*$/gm) || []).length; if (headers >= 3) score += 10; return Math.min(score, 100); } catch (error) { console.error('Error analyzing content quality:', error); return 40; } } private async analyzeAccessibility(request: SEOOptimizationRequest): Promise<number> { try { let score = 70; // Base score // Image alt text simulation const images = (request.content.match(/!\[.*?\]\(.*?\)/g) || []); const imagesWithAlt = images.filter(img => img.match(/!\[.*?\]/) && img.match(/!\[.*?\]/)[0].length > 3); if (images.length > 0) { score += (imagesWithAlt.length / images.length) * 20; } // Header structure const headers = request.content.match(/^#{1,6}\s+(.+)$/gm) || []; const headerLevels = headers.map(h => h.match(/^#{1,6}/)[0].length); // Check for proper header hierarchy let properHierarchy = true; for (let i = 1; i < headerLevels.length; i++) { if (headerLevels[i] > headerLevels[i - 1] + 1) { properHierarchy = false; break; } } if (properHierarchy) score += 20; // Link text const links = (request.content.match(/\[.*?\]\(.*?\)/g) || []); const descriptiveLinks = links.filter(link => { const text = link.match(/\[(.*?)\]/)[1]; return text.length > 5 && !text.match(/click here|link|more/gi); }); if (links.length > 0) { score += (descriptiveLinks.length / links.length) * 10; } return Math.min(score, 100); } catch (error) { console.error('Error analyzing accessibility:', error); return 50; } } private async analyzeSecurity(request: SEOOptimizationRequest): Promise<number> { try { let score = 90; // Base score // Check for external links to potentially insecure sites const httpLinks = (request.content.match(/\[.*?\]\(http:\/\/.*?\)/g) || []).length; if (httpLinks > 0) score -= httpLinks * 10; // Check for potentially sensitive content patterns const sensitivePatterns = [ /password/gi, /credit.*card/gi, /ssn/gi, /social.*security/gi ]; const sensitiveContent = sensitivePatterns.filter(pattern => pattern.test(request.content)); if (sensitiveContent.length > 0) score -= sensitiveContent.length * 15; return Math.max(score, 0); } catch (error) { console.error('Error analyzing security:', error); return 70; } } private generateTechnicalRecommendations(audit: TechnicalSEOAudit): string[] { const recommendations: string[] = []; // Page speed recommendations if (audit.page_speed_score < 70) { recommendations.push('Optimize images and reduce file sizes for faster loading'); recommendations.push('Minimize external HTTP requests and enable browser caching'); } // Mobile recommendations if (audit.mobile_friendliness < 70) { recommendations.push('Improve mobile responsiveness and readability'); recommendations.push('Optimize content layout for smaller screens'); } // Core Web Vitals recommendations if (audit.core_web_vitals.lcp > 2.5) { recommendations.push('Optimize largest contentful paint by improving image loading'); } if (audit.core_web_vitals.fid > 100) { recommendations.push('Reduce JavaScript execution time for better interactivity'); } if (audit.core_web_vitals.cls > 0.1) { recommendations.push('Prevent layout shifts by specifying image dimensions'); } // Meta tags recommendations if (audit.meta_tags_optimization < 70) { recommendations.push('Optimize meta titles and descriptions for better CTR'); } // Structured data recommendations if (audit.structured_data_score < 50) { recommendations.push('Implement structured data for better rich snippets'); } // Internal linking recommendations if (audit.internal_linking_score < 50) { recommendations.push('Improve internal linking structure for better SEO'); } // Content quality recommendations if (audit.content_quality_score < 60) { recommendations.push('Improve content quality and depth'); } // Accessibility recommendations if (audit.accessibility_score < 70) { recommendations.push('Improve accessibility with better alt text and header structure'); } return recommendations; } private identifyCriticalIssues(audit: TechnicalSEOAudit): string[] { const criticalIssues: string[] = []; if (audit.page_speed_score < 40) { criticalIssues.push('Critical: Page speed significantly impacts user experience and SEO rankings'); } if (audit.mobile_friendliness < 40) { criticalIssues.push('Critical: Mobile usability issues affecting mobile search rankings'); } if (audit.core_web_vitals.lcp > 4.0) { criticalIssues.push('Critical: Very slow loading times impacting user experience'); } if (audit.security_score < 50) { criticalIssues.push('Critical: Security vulnerabilities detected'); } return criticalIssues; } async optimizePageWideSEO(pageType: 'home' | 'broker_profile' | 'brokers_list' | 'blog' | 'comparison' | 'guide'): Promise<PageWideOptimization> { try { console.log(`Performing page-wide SEO optimization for: ${pageType}`); const technicalAudit = await this.performTechnicalSEOAudit({ content: '', title: '', content_type: pageType, target_keywords: [], broker_data: null, include_structured_data: true, optimize_for_snippets: true, page_type: pageType, mobile_optimization: true, core_web_vitals: true, technical_audit: true, comprehensive_optimization: true }); const optimizationStrategy = this.generatePageWideOptimizationStrategy(pageType, technicalAudit); const pageOptimization: PageWideOptimization = { page_type: pageType, technical_audit: technicalAudit, optimization_strategy: optimizationStrategy, implementation_priority: this.determineImplementationPriority(technicalAudit), estimated_impact: this.estimateImpact(technicalAudit), timeline_weeks: this.estimateTimeline(technicalAudit) }; return pageOptimization; } catch (error) { console.error('Error performing page-wide SEO optimization:', error); throw error; } } private generatePageWideOptimizationStrategy(pageType: string, audit: TechnicalSEOAudit): string[] { const strategy: string[] = []; // Common strategies for all page types strategy.push('Implement comprehensive meta tag optimization'); strategy.push('Enhance structured data markup'); strategy.push('Optimize Core Web Vitals'); strategy.push('Improve mobile responsiveness'); // Page-specific strategies switch (pageType) { case 'home': strategy.push('Create comprehensive homepage schema markup'); strategy.push('Optimize for branded and high-intent keywords'); strategy.push('Implement local business structured data'); break; case 'broker_profile': strategy.push('Implement comprehensive financial service schema'); strategy.push('Add review and rating structured data'); strategy.push('Optimize for broker-specific long-tail keywords'); break; case 'brokers_list': strategy.push('Implement collection page structured data'); strategy.push('Add filtering and sorting schema markup'); strategy.push('Optimize internal linking structure'); break; case 'blog': strategy.push('Implement article and blog posting schema'); strategy.push('Add author and publisher structured data'); strategy.push('Optimize content for featured snippets'); break; case 'comparison': strategy.push('Implement comparison schema markup'); strategy.push('Add product and service structured data'); strategy.push('Optimize for comparison keywords'); break; case 'guide': strategy.push('Implement how-to and tutorial schema markup'); strategy.push('Add step-by-step structured data'); strategy.push('Optimize for educational and informational queries'); break; } // Add recommendations based on audit results if (audit.page_speed_score < 70) { strategy.push('Implement page speed optimization techniques'); } if (audit.mobile_friendliness < 70) { strategy.push('Enhance mobile user experience'); } return strategy; } private determineImplementationPriority(audit: TechnicalSEOAudit): 'high' | 'medium' | 'low' { const criticalScore = audit.critical_issues.length; const overallScore = (audit.page_speed_score + audit.mobile_friendliness + audit.core_web_vitals.lcp) / 3; if (criticalScore > 2 || overallScore < 40) return 'high'; if (criticalScore > 0 || overallScore < 60) return 'medium'; return 'low'; } private estimateImpact(audit: TechnicalSEOAudit): 'significant' | 'moderate' | 'minimal' { const currentScore = (audit.page_speed_score + audit.mobile_friendliness + audit.meta_tags_optimization) / 3; if (currentScore < 50) return 'significant'; if (currentScore < 70) return 'moderate'; return 'minimal'; } private estimateTimeline(audit: TechnicalSEOAudit): number { const priority = this.determineImplementationPriority(audit); const impact = this.estimateImpact(audit); if (priority === 'high' && impact === 'significant') return 4; if (priority === 'high' || impact === 'significant') return 3; if (priority === 'medium' || impact === 'moderate') return 2; return 1; } async optimizeAllPages(): Promise<PageWideOptimization[]> { try { console.log('Performing comprehensive SEO optimization across all page types'); const pageTypes: ('home' | 'broker_profile' | 'brokers_list' | 'blog' | 'comparison' | 'guide')[] = [ 'home', 'broker_profile', 'brokers_list', 'blog', 'comparison', 'guide' ]; const optimizations: PageWideOptimization[] = []; for (const pageType of pageTypes) { console.log(`Optimizing ${pageType} pages...`); const optimization = await this.optimizePageWideSEO(pageType); optimizations.push(optimization); } console.log(`Completed comprehensive SEO optimization for ${optimizations.length} page types`); return optimizations; } catch (error) { console.error('Error performing comprehensive SEO optimization:', error); throw error; } } }