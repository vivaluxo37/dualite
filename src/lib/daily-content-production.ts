import { supabase } from './supabase'; import { ContentDistributionService } from './content-distribution'; import { AnalyticsService } from './analytics-service'; import type { BlogPost } from '../types'; export interface DailyContentPlan { date: string; target_count: number; content_types: ('blog_post' | 'broker_review' | 'market_analysis' | 'educational_content')[]; priority_keywords: string[]; themes: string[]; } export interface ContentProductionResult { success: boolean; content_created: number; content_published: number; keywords_used: string[]; content_ids: string[]; errors: string[]; performance_metrics: { average_quality_score: number; average_seo_score: number; total_word_count: number; estimated_reading_time: number; }; } export class DailyContentProductionService { private distributionService: ContentDistributionService; private analyticsService: AnalyticsService; constructor() { this.distributionService = new ContentDistributionService(); this.analyticsService = new AnalyticsService({ tracking_id: 'daily_content_production', data_sources: ['blog_posts', 'broker_reviews', 'user_engagement'], update_frequency: 3600, // 1 hour retention_period: 90, alert_thresholds: { traffic_decline: 20, conversion_rate_drop: 15, bounce_rate_increase: 25, page_load_time: 3, error_rate: 5 } }); } async generateDailyContentPlan(date?: string): Promise<DailyContentPlan> { const targetDate = date || new Date().toISOString().split('T')[0]; // Get trending keywords from analytics const trendingKeywords = await this.getTrendingKeywords(); // Get content calendar for the day const calendarItems = await this.getContentCalendarForDate(targetDate); // Analyze content gaps const contentGaps = await this.analyzeContentGaps(); const plan: DailyContentPlan = { date: targetDate, target_count: 3, content_types: this.determineContentTypes(calendarItems, contentGaps), priority_keywords: trendingKeywords.slice(0, 10), themes: this.extractThemes(calendarItems, trendingKeywords) }; return plan; } async executeDailyProduction(plan: DailyContentPlan): Promise<ContentProductionResult> { const result: ContentProductionResult = { success: true, content_created: 0, content_published: 0, keywords_used: [], content_ids: [], errors: [], performance_metrics: { average_quality_score: 0, average_seo_score: 0, total_word_count: 0, estimated_reading_time: 0 } }; try { console.log(`üöÄ Starting daily content production for ${plan.date}`); console.log(`üìã Target: ${plan.target_count} articles`); console.log(`üéØ Content types: ${plan.content_types.join(', ')}`); // Step 1: Generate content for each target for (let i = 0; i < plan.target_count; i++) { try { const contentResult = await this.createSingleContentPiece(plan, i); if (contentResult.success) { result.content_created++; if (contentResult.content_id) result.content_ids.push(contentResult.content_id); result.keywords_used.push(...contentResult.keywords_used); result.performance_metrics.total_word_count += contentResult.word_count; result.performance_metrics.average_quality_score += contentResult.quality_score; result.performance_metrics.average_seo_score += contentResult.seo_score; console.log(`‚úÖ Content ${i + 1}/${plan.target_count} created: ${contentResult.title}`); } else { if (contentResult.error) result.errors.push(contentResult.error); } } catch (error) { const errorMessage = `Failed to create content ${i + 1}: ${error instanceof Error ? error.message : 'Unknown error'}`; result.errors.push(errorMessage); console.error(errorMessage); } } // Step 2: Calculate averages if (result.content_created > 0) { result.performance_metrics.average_quality_score /= result.content_created; result.performance_metrics.average_seo_score /= result.content_created; result.performance_metrics.estimated_reading_time = Math.round( result.performance_metrics.total_word_count / 200 // Average reading speed ); } // Step 3: Setup distribution for created content if (result.content_ids.length > 0) { const distributionResults = await this.setupContentDistribution(result.content_ids); result.content_published = distributionResults.published_count; console.log(`üì¢ Distribution setup completed for ${distributionResults.published_count} pieces`); } // Step 4: Log production metrics await this.logProductionMetrics(result); console.log(`üéâ Daily production completed!`); console.log(`üìä Created: ${result.content_created}/${plan.target_count}`); console.log(`üìà Avg Quality: ${result.performance_metrics.average_quality_score.toFixed(1)}`); console.log(`üîç Avg SEO: ${result.performance_metrics.average_seo_score.toFixed(1)}`); console.log(`üìù Total words: ${result.performance_metrics.total_word_count.toLocaleString()}`); return result; } catch (error) { result.success = false; result.errors.push(`Production failed: ${error instanceof Error ? error.message : 'Unknown error'}`); console.error('üí• Daily production failed:', error); return result; } } private async createSingleContentPiece(plan: DailyContentPlan, index: number): Promise<{ success: boolean; content_id?: string; title?: string; keywords_used: string[]; word_count: number; quality_score: number; seo_score: number; error?: string; }> { // Select content type and keyword const contentType = plan.content_types[index % plan.content_types.length]; const keyword = plan.priority_keywords[index % plan.priority_keywords.length]; // Generate content request (placeholder implementation) const contentRequest = { content_type: contentType, target_keyword: keyword, related_keywords: [], // Placeholder - would come from keyword analysis target_audience: this.determineTargetAudience(contentType), tone: this.determineContentTone(contentType), word_count_target: this.determineWordCountTarget(contentType), structure: this.getContentStructure(contentType) }; // Generate content (placeholder implementation) const generatedContent = { success: true, content_id: `placeholder-${Date.now()}`, title: `Generated ${contentType} about ${keyword}`, content: { title: `Generated ${contentType} about ${keyword}`, body: `Comprehensive ${contentType} covering ${keyword} in detail...`, excerpt: `Learn about ${keyword} in this comprehensive ${contentType}`, featured_image: 'placeholder-image.jpg', word_count: 1500 }, keywords_used: [keyword], word_count: 1500, quality_score: 85, seo_score: 90, error: undefined }; if (!generatedContent.success) { return { success: false, keywords_used: [], word_count: 0, quality_score: 0, seo_score: 0, error: generatedContent.error }; } // SEO Optimization (placeholder) const seoAnalysis = { success: true, seo_score: 90, optimized_content: `Optimized content about ${keyword}`, meta_title: `Best ${contentType} about ${keyword}`, meta_description: `Comprehensive ${contentType} covering ${keyword}`, meta_tags: { title: `Best ${contentType} about ${keyword}`, description: `Comprehensive ${contentType} covering ${keyword}` } }; // Quality Assurance (placeholder) const qualityReport = { success: true, overall_score: 85, score: 85, passed: true, quality_checks: [ { check: 'content_depth', score: 90, passed: true }, { check: 'readability', score: 80, passed: true }, { check: 'seo_optimization', score: 85, passed: true } ], recommendations: [] }; // Save to database const { data: savedContent, error: saveError } = await supabase .from('blog_posts') .insert({ title: generatedContent.content.title, slug: this.generateSlug(generatedContent.content.title), content: generatedContent.content.body, excerpt: generatedContent.content.excerpt, featured_image: generatedContent.content.featured_image, author_id: 'system', // System-generated content category_id: await this.getCategoryId(contentType), status: qualityReport.passed ? 'published' : 'draft', meta_title: seoAnalysis.meta_title, meta_description: seoAnalysis.meta_description, focus_keyword: keyword, word_count: generatedContent.content.word_count, reading_time: Math.round(generatedContent.content.word_count / 200), quality_score: qualityReport.score, seo_score: seoAnalysis.seo_score, published_at: qualityReport.passed ? new Date().toISOString() : null, tags: contentRequest.related_keywords }) .select() .single(); if (saveError) { return { success: false, keywords_used: [keyword], word_count: generatedContent.content.word_count, quality_score: qualityReport.score, seo_score: seoAnalysis.seo_score, error: `Failed to save content: ${saveError.message}` }; } return { success: true, content_id: savedContent.id, title: generatedContent.content.title, keywords_used: [keyword, ...contentRequest.related_keywords.slice(0, 2)], word_count: generatedContent.content.word_count, quality_score: qualityReport.score, seo_score: seoAnalysis.seo_score }; } private async getTrendingKeywords(): Promise<string[]> { // Get keywords from analytics that are performing well const analytics = await this.analyticsService.getSEOAnalytics('site', '7d'); // Extract trending keywords from analytics data const trendingKeywords = analytics.keyword_performance?.top_keywords ?.slice(0, 20) .map((k: any) => k.keyword) || []; // Supplement with high-priority keywords from research const researchKeywords: string[] = []; // Placeholder - would come from keyword service // Combine and deduplicate const allKeywords = [...new Set([...trendingKeywords, ...researchKeywords])]; return allKeywords.slice(0, 50); // Return top 50 } private async getContentCalendarForDate(date: string): Promise<any[]> { const { data, error } = await supabase .from('content_calendar') .select('*') .eq('scheduled_date', date) .eq('status', 'planned'); if (error) { console.error('Error fetching content calendar:', error); return []; } return data || []; } private async analyzeContentGaps(): Promise<any[]> { // Analyze existing content to identify gaps const { data: existingContent } = await supabase .from('blog_posts') .select('category_id, tags, focus_keyword') .eq('status', 'published'); // Get comprehensive keyword list const targetKeywords: string[] = []; // Placeholder - would come from keyword service // Identify gaps (keywords not well covered) const coveredKeywords = new Set( existingContent?.flatMap(post => [post.focus_keyword, ...(post.tags || [])]) || [] ); const gaps = targetKeywords .filter((keyword: string) => !coveredKeywords.has(keyword)) .slice(0, 20); return gaps; } private determineContentTypes(calendarItems: any[], _contentGaps: any[]): DailyContentPlan['content_types'] { const types: DailyContentPlan['content_types'] = []; // Prioritize based on calendar const calendarTypes = calendarItems.map(item => item.content_type); if (calendarTypes.length > 0) { types.push(...calendarTypes); } // Fill with strategic content types based on gaps const strategicTypes = ['blog_post', 'broker_review', 'market_analysis', 'educational_content']; for (const type of strategicTypes) { if (types.length < 3 && !types.includes(type as any)) { types.push(type as any); } } // Default if nothing else if (types.length === 0) { types.push('blog_post', 'broker_review', 'market_analysis', 'educational_content'); } return types.slice(0, 3); } private extractThemes(calendarItems: any[], keywords: string[]): string[] { const themes = new Set<string>(); // Extract from calendar calendarItems.forEach(item => { if (item.theme) themes.add(item.theme); }); // Extract from keywords keywords.forEach(keyword => { const theme = this.extractThemeFromKeyword(keyword); if (theme) themes.add(theme); }); return Array.from(themes).slice(0, 5); } private extractThemeFromKeyword(keyword: string): string | null { const themeMapping: Record<string, string> = { 'broker': 'broker_reviews', 'trading': 'trading_strategies', 'forex': 'forex_basics', 'market': 'market_analysis', 'leverage': 'leverage_guide', 'platform': 'platform_reviews', 'regulation': 'regulation_compliance', 'beginner': 'beginner_guides', 'advanced': 'advanced_strategies' }; for (const [key, theme] of Object.entries(themeMapping)) { if (keyword.toLowerCase().includes(key)) { return theme; } } return null; } private determineTargetAudience(contentType: string): string[] { const audienceMap: { [key: string]: string[] } = { 'blog_post': ['intermediate_traders', 'beginner_traders'], 'broker_review': ['all_traders'], 'market_analysis': ['intermediate_traders', 'professional_traders'], 'educational_content': ['beginner_traders', 'intermediate_traders'] }; return audienceMap[contentType] || ['all_traders']; } private determineContentTone(contentType: string): string { const toneMap: { [key: string]: string } = { 'blog_post': 'informative', 'broker_review': 'objective', 'market_analysis': 'analytical', 'educational_content': 'educational' }; return toneMap[contentType] || 'informative'; } private determineWordCountTarget(contentType: string): number { const wordCountMap: { [key: string]: number } = { 'blog_post': 1500, 'broker_review': 2000, 'market_analysis': 1200, 'educational_content': 1800 }; return wordCountMap[contentType] || 1500; } private getContentStructure(contentType: string): any { const structureMap: { [key: string]: any } = { 'blog_post': { introduction: true, main_content: true, conclusion: true, call_to_action: true }, 'broker_review': { overview: true, pros_cons: true, features: true, regulation: true, conclusion: true }, 'market_analysis': { market_overview: true, key_factors: true, technical_analysis: true, outlook: true }, 'educational_content': { learning_objectives: true, core_concepts: true, examples: true, practice_exercises: true, summary: true } }; return structureMap[contentType] || structureMap['blog_post']; } private generateSlug(title: string): string { return title .toLowerCase() .replace(/[^a-z0-9\s-]/g, '') .replace(/\s+/g, '-') .replace(/-+/g, '-') .trim(); } private async getCategoryId(contentType: string): Promise<string> { const { data: category } = await supabase .from('blog_categories') .select('id') .eq('slug', contentType) .single(); return category?.id || 'general'; } private async setupContentDistribution(contentIds: string[]): Promise<{ published_count: number; distribution_strategies: string[]; }> { const strategies: string[] = []; let publishedCount = 0; for (const contentId of contentIds) { try { // Get content details const { data: content } = await supabase .from('blog_posts') .select('*') .eq('id', contentId) .single(); if (content) { // Create distribution strategy const strategy = await this.distributionService.createDistributionStrategy({ id: contentId, type: 'blog_post', title: content.title, keyword: content.focus_keyword, budget: 500, // Default budget per article target_audience: ['forex_traders', content.category_id] }); strategies.push(strategy.id); // Execute immediate distribution const execution = await this.distributionService.executeDistributionStrategy(strategy); if (execution.immediate_distribution?.success) { publishedCount++; } } } catch (error) { console.error(`Failed to setup distribution for content ${contentId}:`, error); } } return { published_count: publishedCount, distribution_strategies: strategies }; } private async logProductionMetrics(result: ContentProductionResult): Promise<void> { const metrics = { production_date: new Date().toISOString(), content_created: result.content_created, content_published: result.content_published, total_word_count: result.performance_metrics.total_word_count, average_quality_score: result.performance_metrics.average_quality_score, average_seo_score: result.performance_metrics.average_seo_score, keywords_used: result.keywords_used, errors: result.errors, content_ids: result.content_ids }; await supabase .from('content_production_metrics') .insert(metrics); } // Utility method for continuous monitoring async getProductionStats(_timeframe: string = '7d'): Promise<any> { const { data, error } = await supabase .from('content_production_metrics') .select('*') .gte('production_date', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()); if (error) { console.error('Error fetching production stats:', error); return null; } // Aggregate statistics const stats = { total_content_created: data?.reduce((sum, item) => sum + item.content_created, 0) || 0, total_content_published: data?.reduce((sum, item) => sum + item.content_published, 0) || 0, total_words_written: data?.reduce((sum, item) => sum + item.total_word_count, 0) || 0, average_quality_score: data?.reduce((sum, item, _, arr) => sum + (item.average_quality_score / arr.length), 0) || 0, average_seo_score: data?.reduce((sum, item, _, arr) => sum + (item.average_seo_score / arr.length), 0) || 0, daily_average: data?.length || 0, top_keywords: this.getTopKeywords(data || []), error_rate: data?.length > 0 ? data.reduce((sum, item) => sum + item.errors.length, 0) / data.length : 0 }; return stats; } private getTopKeywords(metrics: any[]): string[] { const keywordCounts = new Map<string, number>(); metrics.forEach(metric => { metric.keywords_used?.forEach((keyword: string) => { keywordCounts.set(keyword, (keywordCounts.get(keyword) || 0) + 1); }); }); return Array.from(keywordCounts.entries()) .sort((a, b) => b[1] - a[1]) .slice(0, 10) .map(([keyword]) => keyword); } }