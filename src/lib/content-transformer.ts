// Content Transformation Pipeline for LLM SEO Optimization // Transforms existing content into LLM-friendly, SEO-optimized format import { LLMSEOOptimizer, LLMOptimizationResult, LLMEntity, FAQItem, TOCItem, InternalLink } from './llm-seo-optimization'; import { SchemaGenerator, CompleteSchemaMarkup } from './schema-generator'; export interface TransformationOptions { generateKeyTakeaways: boolean; generateTOC: boolean; convertHeadingsToQuestions: boolean; enhanceWithEntities: boolean; generateFAQBlocks: boolean; addInternalLinks: boolean; schemaTypes: ('faq' | 'speakable' | 'article' | 'breadcrumb' | 'howto')[]; maxFAQsPerSection: number; internalLinksCount: number; } export interface TransformationResult { success: boolean; transformedContent: string; schemaMarkup: CompleteSchemaMarkup; optimizationData: LLMOptimizationResult; processingTime: number; errors?: string[]; warnings?: string[]; } export interface RelatedArticle { id: string; title: string; slug: string; url: string; excerpt: string; category: string; tags: string[]; relevanceScore: number; } export class ContentTransformer { private optimizer: LLMSEOOptimizer; private schemaGenerator: SchemaGenerator; private defaultOptions: TransformationOptions; constructor() { this.optimizer = new LLMSEOOptimizer(); this.schemaGenerator = new SchemaGenerator(); this.defaultOptions = { generateKeyTakeaways: true, generateTOC: true, convertHeadingsToQuestions: true, enhanceWithEntities: true, generateFAQBlocks: true, addInternalLinks: true, schemaTypes: ['faq', 'speakable', 'article', 'breadcrumb'], maxFAQsPerSection: 3, internalLinksCount: 3 }; } /** * Transform blog content with LLM SEO optimizations */ async transformBlogPost( content: string, title: string, publishDate: string, options: Partial<TransformationOptions> = {}, metadata: { excerpt?: string; imageUrl?: string; url?: string; category?: string; tags?: string[]; keywords?: string[]; author?: string; updateDate?: string; relatedArticles?: RelatedArticle[]; } = {} ): Promise<TransformationResult> { const startTime = Date.now(); const errors: string[] = []; const warnings: string[] = []; try { // Merge options with defaults const transformationOptions = { ...this.defaultOptions, ...options }; // Step 1: Get related articles if not provided const relatedArticles = metadata.relatedArticles || await this.getRelatedArticles(title, metadata.tags || []); // Step 2: Run LLM optimization const optimizationResult = await this.optimizer.optimizeContent(content, title, relatedArticles); // Step 3: Build transformed content structure let transformedContent = this.buildContentStructure( optimizationResult.optimizedContent, title, optimizationResult, transformationOptions, metadata ); // Step 4: Add FAQ blocks under sections if requested if (transformationOptions.generateFAQBlocks) { transformedContent = this.addFAQBlocksToSections( transformedContent, optimizationResult.faqs, transformationOptions.maxFAQsPerSection ); } // Step 5: Generate schema markup const schemaMarkup = this.generateCompleteSchema( title, metadata.excerpt || this.generateExcerpt(content), transformedContent, publishDate, optimizationResult, metadata.tags || [], metadata.category, transformationOptions.schemaTypes, metadata.updateDate, metadata.imageUrl, metadata.url ); // Step 6: Validate transformation const validation = this.validateTransformation(transformedContent, schemaMarkup); errors.push(...validation.errors); warnings.push(...validation.warnings); const processingTime = Date.now() - startTime; return { success: errors.length === 0, transformedContent, schemaMarkup, optimizationData: optimizationResult, processingTime, errors: errors.length > 0 ? errors : undefined, warnings: warnings.length > 0 ? warnings : undefined }; } catch (error) { const processingTime = Date.now() - startTime; return { success: false, transformedContent: content, // Return original content on error schemaMarkup: { '@context': 'https://schema.org', '@graph': [] }, optimizationData: { optimizedContent: content, entities: [], faqs: [], speakableSections: [], keyTakeaways: [], tableOfContents: [], internalLinks: [], schemaMarkup: { faq: [], speakable: {}, article: {}, breadcrumb: {} } }, processingTime, errors: [`Transformation failed: ${error instanceof Error ? error.message : 'Unknown error'}`] }; } } /** * Build enhanced content structure */ private buildContentStructure( content: string, _title: string, optimizationResult: LLMOptimizationResult, options: TransformationOptions, _metadata: any ): string { let transformedContent = ''; // Add key takeaways at the top if (options.generateKeyTakeaways && optimizationResult.keyTakeaways.length > 0) { transformedContent += this.generateKeyTakeawaysSection(optimizationResult.keyTakeaways); transformedContent += '\n\n'; } // Add table of contents if (options.generateTOC && optimizationResult.tableOfContents.length > 0) { transformedContent += this.generateTOCSection(optimizationResult.tableOfContents); transformedContent += '\n\n'; } // Add main content transformedContent += content; // Add internal links section if (options.addInternalLinks && optimizationResult.internalLinks.length > 0) { transformedContent += '\n\n'; transformedContent += this.generateInternalLinksSection(optimizationResult.internalLinks); } return transformedContent; } /** * Generate key takeaways section */ private generateKeyTakeawaysSection(keyTakeaways: string[]): string { return `## Key Takeaways: Quick Answers to Common Questions ${keyTakeaways.map((takeaway, index) => `${index + 1}. ${takeaway}`).join('\n\n')} --- `; } /** * Generate table of contents section */ private generateTOCSection(tocItems: TOCItem[]): string { let toc = '## Table of Contents\n\n'; tocItems.forEach(item => { const indent = ' '.repeat(item.level - 2); const anchor = item.anchor.replace(/^#+/, ''); toc += `${indent}- [${item.text}](#${anchor})\n`; }); return toc; } /** * Generate internal links section */ private generateInternalLinksSection(internalLinks: InternalLink[]): string { const links = internalLinks .sort((a, b) => b.relevanceScore - a.relevanceScore) .slice(0, 3); if (links.length === 0) return ''; return `## Related Articles ${links.map(link => `- [${link.anchorText}](${link.url}) - ${link.context}`).join('\n')} --- `; } /** * Add FAQ blocks under relevant sections */ private addFAQBlocksToSections(content: string, faqs: FAQItem[], maxPerSection: number): string { const lines = content.split('\n'); let transformedContent = ''; let currentSection = ''; let sectionLevel = 0; for (let i = 0; i < lines.length; i++) { const line = lines[i]; // Detect heading changes const headingMatch = line.match(/^(#{2,4})\s+(.+)$/); if (headingMatch) { // Add FAQ block for previous section if we have relevant FAQs if (currentSection && sectionLevel >= 2) { const sectionFAQs = this.getRelevantFAQsForSection(currentSection, faqs, maxPerSection); if (sectionFAQs.length > 0) { transformedContent += this.generateFAQBlockForSection(sectionFAQs); transformedContent += '\n'; } } // Start new section currentSection = headingMatch[2]; sectionLevel = headingMatch[1].length; } transformedContent += line + '\n'; } // Add FAQ block for final section if (currentSection && sectionLevel >= 2) { const sectionFAQs = this.getRelevantFAQsForSection(currentSection, faqs, maxPerSection); if (sectionFAQs.length > 0) { transformedContent += this.generateFAQBlockForSection(sectionFAQs); } } return transformedContent; } /** * Get relevant FAQs for a specific section */ private getRelevantFAQsForSection(sectionTitle: string, faqs: FAQItem[], maxCount: number): FAQItem[] { const sectionKeywords = sectionTitle.toLowerCase().split(/\s+/); const relevantFAQs = faqs .map(faq => ({ ...faq, relevanceScore: this.calculateFAQRelevance(faq, sectionKeywords) })) .filter(faq => faq.relevanceScore > 0.3) .sort((a, b) => b.relevanceScore - a.relevanceScore) .slice(0, maxCount); return relevantFAQs; } /** * Calculate FAQ relevance to section */ private calculateFAQRelevance(faq: FAQItem, sectionKeywords: string[]): number { let score = 0; const questionLower = faq.question.toLowerCase(); const answerLower = faq.answer.toLowerCase(); sectionKeywords.forEach(keyword => { if (keyword.length > 3) { if (questionLower.includes(keyword)) score += 0.5; if (answerLower.includes(keyword)) score += 0.3; } }); return Math.min(score, 1.0); } /** * Generate FAQ block for a section */ private generateFAQBlockForSection(faqs: FAQItem[]): string { let faqBlock = '\n### Frequently Asked Questions\n\n'; faqs.forEach((faq, index) => { faqBlock += `**Q${index + 1}: ${faq.question}**\n\n`; faqBlock += `${faq.answer}\n\n`; }); return faqBlock; } /** * Generate complete schema markup */ private generateCompleteSchema( _title: string, excerpt: string, content: string, publishDate: string, optimizationResult: LLMOptimizationResult, tags: string[] = [], category?: string, schemaTypes: string[] = [], updateDate?: string, imageUrl?: string, url?: string ): CompleteSchemaMarkup { // Filter FAQs and speakable sections based on schema types const includeFAQ = schemaTypes.includes('faq'); const includeSpeakable = schemaTypes.includes('speakable'); const faqs = includeFAQ ? optimizationResult.faqs : []; const speakableSections = includeSpeakable ? optimizationResult.speakableSections : []; // Generate breadcrumbs const breadcrumbs = schemaTypes.includes('breadcrumb') ? this.schemaGenerator.generateBlogBreadcrumbs(_title, category) : []; return this.schemaGenerator.generateCompleteSchema( _title, excerpt, content, publishDate, updateDate, imageUrl, url, faqs, speakableSections, optimizationResult.entities, tags, breadcrumbs ); } /** * Get related articles from database */ private async getRelatedArticles(_title: string, _tags: string[]): Promise<RelatedArticle[]> { try { // This would typically query your database for related articles // For now, we'll return a placeholder implementation return []; } catch (error) { console.warn('Failed to get related articles:', error); return []; } } /** * Generate excerpt from content */ private generateExcerpt(content: string): string { // Remove markdown and get first meaningful paragraph const cleanContent = content .replace(/^#{1,6}\s+/gm, '') .replace(/\*\*([^*]+)\*\*/g, '$1') .replace(/\*([^*]+)\*/g, '$1') .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') .trim(); const sentences = cleanContent.split(/[.!?]+/).filter(s => s.trim().length > 20); const excerpt = sentences.slice(0, 2).join('. ').trim(); return excerpt.length > 160 ? excerpt.substring(0, 157) + '...' : excerpt; } /** * Validate transformation result */ private validateTransformation(content: string, schema: CompleteSchemaMarkup): { errors: string[], warnings: string[] } { const errors: string[] = []; const warnings: string[] = []; // Validate content structure if (!content.includes('## Key Takeaways')) { warnings.push('Key takeaways section not found'); } if (!content.includes('## Table of Contents')) { warnings.push('Table of contents not found'); } if (!content.includes('### Frequently Asked Questions')) { warnings.push('FAQ sections not found'); } // Validate schema const schemaValidation = this.schemaGenerator.validateSchema(schema); errors.push(...schemaValidation.errors); // Note: schemaValidation doesn't have warnings property according to interface return { errors, warnings }; } /** * Transform multiple blog posts in batch */ async transformBatch( posts: Array<{ id: string; content: string; title: string; publishDate: string; metadata?: any; }>, options: Partial<TransformationOptions> = {} ): Promise<Array<{ postId: string; result: TransformationResult; }>> { const results: Array<{ postId: string; result: TransformationResult; }> = []; for (const post of posts) { try { const result = await this.transformBlogPost( post.content, post.title, post.publishDate, options, post.metadata ); results.push({ postId: post.id, result }); } catch (error) { results.push({ postId: post.id, result: { success: false, transformedContent: post.content, schemaMarkup: { '@context': 'https://schema.org', '@graph': [] }, optimizationData: { optimizedContent: post.content, entities: [], faqs: [], speakableSections: [], keyTakeaways: [], tableOfContents: [], internalLinks: [], schemaMarkup: { faq: [], speakable: {}, article: {}, breadcrumb: {} } }, processingTime: 0, errors: [`Batch processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`] } }); } } return results; } /** * Generate transformation report */ generateTransformationReport(results: TransformationResult[]): { totalPosts: number; successfulTransformations: number; failedTransformations: number; averageProcessingTime: number; totalEntitiesExtracted: number; totalFAQsGenerated: number; totalSchemaGenerated: number; errors: string[]; warnings: string[]; } { const successful = results.filter(r => r.success); const failed = results.filter(r => !r.success); return { totalPosts: results.length, successfulTransformations: successful.length, failedTransformations: failed.length, averageProcessingTime: results.reduce((sum, r) => sum + r.processingTime, 0) / results.length, totalEntitiesExtracted: results.reduce((sum, r) => sum + r.optimizationData.entities.length, 0), totalFAQsGenerated: results.reduce((sum, r) => sum + r.optimizationData.faqs.length, 0), totalSchemaGenerated: successful.length, errors: results.flatMap(r => r.errors || []), warnings: results.flatMap(r => r.warnings || []) }; } /** * Export transformation result for database storage */ exportForDatabase(result: TransformationResult, postId: string): { post_id: string; llm_optimized_content: string; faq_schema: any; speakable_schema: any; article_schema: any; entity_references: any[]; internal_links: any[]; optimization_data: any; transformation_metadata: { processing_time: number; transformed_at: string; success: boolean; errors?: string[]; warnings?: string[]; }; } { return { post_id: postId, llm_optimized_content: result.transformedContent, faq_schema: result.schemaMarkup['@graph'].find((item: any) => item['@type'] === 'FAQPage') || null, speakable_schema: result.schemaMarkup['@graph'].find((item: any) => item.speakable) || null, article_schema: result.schemaMarkup['@graph'].find((item: any) => item['@type'] === 'Article') || null, entity_references: result.optimizationData.entities, internal_links: result.optimizationData.internalLinks, optimization_data: { keyTakeaways: result.optimizationData.keyTakeaways, tableOfContents: result.optimizationData.tableOfContents, speakableSections: result.optimizationData.speakableSections }, transformation_metadata: { processing_time: result.processingTime, transformed_at: new Date().toISOString(), success: result.success, errors: result.errors, warnings: result.warnings } }; } }