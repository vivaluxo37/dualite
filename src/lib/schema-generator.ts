// Schema Generation Utilities for LLM SEO Optimization // Generates valid JSON-LD schema markup for search engines and AI systems import { FAQItem, SpeakableSection, LLMEntity } from './llm-seo-optimization'; export interface FAQSchemaItem { '@type': 'Question'; name: string; acceptedAnswer: { '@type': 'Answer'; text: string; }; } export interface SpeakableSchema { '@type': 'SpeakableSpecification'; cssSelector?: string[]; xpath?: string[]; } export interface ArticleSchema { '@type': 'Article'; headline: string; description: string; image?: string; datePublished: string; dateModified?: string; author: { '@type': 'Organization'; name: string; url?: string; }; publisher: { '@type': 'Organization'; name: string; logo?: { '@type': 'ImageObject'; url: string; }; }; mainEntityOfPage?: { '@type': 'WebPage'; '@id': string; }; keywords?: string[]; articleSection?: string; wordCount?: number; speakable?: SpeakableSchema; about?: { '@type': 'Thing'; name: string; description: string; }; } export interface BreadcrumbSchemaItem { '@type': 'ListItem'; position: number; name: string; item?: string; } export interface BreadcrumbSchema { '@type': 'BreadcrumbList'; itemListElement: BreadcrumbSchemaItem[]; } export interface HowToSchema { '@type': 'HowTo'; name: string; description?: string; totalTime?: string; estimatedCost?: { '@type': 'MonetaryAmount'; currency: string; value: string; }; tool?: any[]; step?: HowToStep[]; } export interface HowToStep { '@type': 'HowToStep'; name: string; text: string; image?: string; url?: string; } export interface CompleteSchemaMarkup { '@context': 'https://schema.org'; '@graph': Array<{ '@type': string; [key: string]: any; }>; } export class SchemaGenerator { private siteUrl: string; private siteName: string; constructor(siteUrl: string = 'https://brokeranalysis.com', siteName: string = 'BrokerAnalysis') { this.siteUrl = siteUrl; this.siteName = siteName; } /** * Generate FAQ schema markup */ generateFAQSchema(faqs: FAQItem[]): FAQSchemaItem[] { return faqs.map(faq => ({ '@type': 'Question' as const, name: faq.question, acceptedAnswer: { '@type': 'Answer' as const, text: faq.answer } })); } /** * Generate Speakable schema markup */ generateSpeakableSchema(speakableSections: SpeakableSection[]): SpeakableSchema { const cssSelectors: string[] = []; const xpaths: string[] = []; speakableSections.forEach(section => { if (section.cssSelector) { cssSelectors.push(section.cssSelector); } if (section.xpath) { xpaths.push(section.xpath); } }); const schema: SpeakableSchema = { '@type': 'SpeakableSpecification' }; if (cssSelectors.length > 0) { schema.cssSelector = cssSelectors; } if (xpaths.length > 0) { schema.xpath = xpaths; } return schema; } /** * Generate Article schema markup */ generateArticleSchema( title: string, description: string, content: string, publishDate: string, updateDate?: string, imageUrl?: string, url?: string, keywords: string[] = [], entities: LLMEntity[] = [], speakableSections: SpeakableSection[] = [] ): ArticleSchema { const wordCount = this.countWords(content); const speakable = speakableSections.length > 0 ? this.generateSpeakableSchema(speakableSections) : undefined; // Extract main entities for about field const mainEntities = entities .filter(e => e.confidence > 0.8) .slice(0, 3) .map(e => e.name); const schema: ArticleSchema = { '@type': 'Article', headline: title, description, datePublished: publishDate, author: { '@type': 'Organization', name: this.siteName, url: this.siteUrl }, publisher: { '@type': 'Organization', name: this.siteName, logo: { '@type': 'ImageObject', url: `${this.siteUrl}/og-image.svg` } }, keywords: keywords.slice(0, 10), // Limit to 10 keywords wordCount }; // Add optional fields if (updateDate) { schema.dateModified = updateDate; } if (imageUrl) { schema.image = imageUrl; } if (url) { schema.mainEntityOfPage = { '@type': 'WebPage', '@id': url }; } if (speakable) { schema.speakable = speakable; } if (mainEntities.length > 0) { schema.about = { '@type': 'Thing', name: mainEntities.join(', '), description: `Key entities discussed: ${mainEntities.join(', ')}` }; } return schema; } /** * Generate Breadcrumb schema markup */ generateBreadcrumbSchema(breadcrumbs: Array<{name: string, url?: string}>): BreadcrumbSchema { const itemListElement: BreadcrumbSchemaItem[] = breadcrumbs.map((crumb, index) => ({ '@type': 'ListItem', position: index + 1, name: crumb.name, item: crumb.url })); return { '@type': 'BreadcrumbList', itemListElement }; } /** * Generate HowTo schema for tutorial content */ generateHowToSchema( name: string, steps: Array<{name: string, text: string, image?: string, url?: string}>, description?: string, totalTime?: string, tools?: Array<{name: string, description?: string}> ): HowToSchema { const stepSchema: HowToStep[] = steps.map((step, index) => ({ '@type': 'HowToStep', name: step.name, text: step.text, ...(step.image && { image: step.image }), ...(step.url && { url: step.url }) })); const schema: HowToSchema = { '@type': 'HowTo', name, step: stepSchema }; if (description) { schema.description = description; } if (totalTime) { schema.totalTime = totalTime; } if (tools && tools.length > 0) { schema.tool = tools.map(tool => ({ '@type': 'HowToTool', name: tool.name, ...(tool.description && { description: tool.description }) })); } return schema; } /** * Generate complete schema markup for a blog post */ generateCompleteSchema( title: string, description: string, content: string, publishDate: string, updateDate?: string, imageUrl?: string, url?: string, faqs: FAQItem[] = [], speakableSections: SpeakableSection[] = [], entities: LLMEntity[] = [], keywords: string[] = [], breadcrumbs: Array<{name: string, url?: string}> = [] ): CompleteSchemaMarkup { const graph: any[] = []; // Add WebPage schema graph.push({ '@type': 'WebPage', '@id': url || `${this.siteUrl}/blog/${this.generateSlug(title)}`, url: url || `${this.siteUrl}/blog/${this.generateSlug(title)}`, name: title, description, isPartOf: { '@type': 'WebSite', '@id': this.siteUrl }, inLanguage: 'en-US' }); // Add Article schema const articleSchema = this.generateArticleSchema( title, description, content, publishDate, updateDate, imageUrl, url, keywords, entities, speakableSections ); graph.push(articleSchema); // Add FAQ schema if FAQs exist if (faqs.length > 0) { graph.push({ '@type': 'FAQPage', mainEntity: this.generateFAQSchema(faqs) }); } // Add Breadcrumb schema if breadcrumbs exist if (breadcrumbs.length > 0) { graph.push(this.generateBreadcrumbSchema(breadcrumbs)); } // Add Organization schema graph.push({ '@type': 'Organization', '@id': `${this.siteUrl}/#organization`, name: this.siteName, url: this.siteUrl, logo: { '@type': 'ImageObject', url: `${this.siteUrl}/og-image.svg`, width: 1200, height: 630 }, sameAs: [ 'https://twitter.com/brokeranalysis', 'https://linkedin.com/company/brokeranalysis' ] }); // Add WebSite schema graph.push({ '@type': 'WebSite', '@id': `${this.siteUrl}/#website`, url: this.siteUrl, name: this.siteName, description: 'Expert forex broker reviews and trading education', publisher: { '@id': `${this.siteUrl}/#organization` }, potentialAction: { '@type': 'SearchAction', target: { '@type': 'EntryPoint', urlTemplate: `${this.siteUrl}/search?q={search_term_string}` }, 'query-input': 'required name=search_term_string' } }); return { '@context': 'https://schema.org', '@graph': graph }; } /** * Generate schema for product reviews (broker reviews) */ generateProductReviewSchema( productName: string, review: { rating: number; author: string; datePublished: string; reviewBody: string; pros?: string[]; cons?: string[]; }, productDetails?: { brand?: string; image?: string; description?: string; url?: string; } ): any { const schema: any = { '@type': 'Review', itemReviewed: { '@type': 'Product', name: productName, ...(productDetails?.brand && { brand: { '@type': 'Brand', name: productDetails.brand } }), ...(productDetails?.image && { image: productDetails.image }), ...(productDetails?.description && { description: productDetails.description }), ...(productDetails?.url && { url: productDetails.url }) }, reviewRating: { '@type': 'Rating', ratingValue: review.rating, bestRating: 5, worstRating: 1 }, author: { '@type': 'Person', name: review.author }, datePublished: review.datePublished, reviewBody: review.reviewBody }; // Add positive and negative notes if available if (review.pros || review.cons) { schema.reviewAspect = []; if (review.pros) { review.pros.forEach(pro => { schema.reviewAspect.push({ '@type': 'ReviewAspect', name: 'Positive', description: pro }); }); } if (review.cons) { review.cons.forEach(con => { schema.reviewAspect.push({ '@type': 'ReviewAspect', name: 'Negative', description: con }); }); } } return schema; } /** * Generate Educational Organization schema */ generateEducationalOrganizationSchema(): any { return { '@type': 'EducationalOrganization', '@id': `${this.siteUrl}/#educational-organization`, name: this.siteName, url: this.siteUrl, description: 'Leading forex trading education and broker review platform', educationalUse: 'Learning, Education, Financial Literacy', audience: { '@type': 'Audience', audienceType: 'Forex Traders, Investors, Financial Students' }, teaches: [ 'Forex Trading', 'Technical Analysis', 'Risk Management', 'Market Analysis', 'Trading Strategies' ], knowsAbout: [ 'Currency Trading', 'Financial Markets', 'Investment Strategies', 'Broker Reviews', 'Trading Platforms' ] }; } /** * Count words in text */ private countWords(text: string): number { return text.trim().split(/\s+/).filter(word => word.length > 0).length; } /** * Generate URL-friendly slug */ private generateSlug(title: string): string { return title .toLowerCase() .replace(/[^\w\s-]/g, '') .replace(/\s+/g, '-') .replace(/-+/g, '-') .trim(); } /** * Validate JSON-LD schema */ validateSchema(schema: any): { isValid: boolean; errors: string[] } { const errors: string[] = []; try { const schemaString = JSON.stringify(schema); // Basic validation checks if (!schema['@context']) { errors.push('Missing @context property'); } if (!schema['@graph'] && !schema['@type']) { errors.push('Missing @type or @graph property'); } if (schema['@graph']) { schema['@graph'].forEach((item: any, index: number) => { if (!item['@type']) { errors.push(`Item ${index} missing @type property`); } }); } // Check for required FAQPage properties if (schema['@type'] === 'FAQPage' || (schema['@graph'] && schema['@graph'].some((g: any) => g['@type'] === 'FAQPage'))) { const faqPage = schema['@type'] === 'FAQPage' ? schema : schema['@graph'].find((g: any) => g['@type'] === 'FAQPage'); if (!faqPage.mainEntity || !Array.isArray(faqPage.mainEntity)) { errors.push('FAQPage missing mainEntity array'); } } return { isValid: errors.length === 0, errors }; } catch (error) { return { isValid: false, errors: [`Invalid JSON: ${error instanceof Error ? error.message : 'Unknown error'}`] }; } } /** * Generate schema as JSON-LD script tag */ generateScriptTag(schema: any): string { const schemaString = JSON.stringify(schema, null, 2); return `<script type="application/ld+json"> ${schemaString} </script>`; } /** * Extract how-to steps from content */ extractHowToSteps(content: string): Array<{name: string, text: string}> { const steps: Array<{name: string, text: string}> = []; // Look for numbered steps const stepRegex = /^(\d+\.|\*\*Step\s*\d+:)\s*([^\n]+)$/gm; let match; while ((match = stepRegex.exec(content)) !== null) { const stepText = match[2]; const stepName = stepText.replace(/^[:\s]+/, '').trim(); // Find the paragraph that follows this step const afterStep = content.substring(match.index + match[0].length); const paragraph = afterStep.split(/\n\n+/)[0].trim(); steps.push({ name: stepName, text: paragraph }); } // Look for step-related headings const headingRegex = /^#{2,3}\s*(?:Step\s*\d+:|How to)\s*([^\n]+)$/gm; while ((match = headingRegex.exec(content)) !== null) { const stepName = match[1].trim(); const afterHeading = content.substring(match.index + match[0].length); const paragraph = afterHeading.split(/\n\n+/)[0].trim(); steps.push({ name: stepName, text: paragraph }); } return steps.slice(0, 10); // Limit to 10 steps } /** * Generate breadcrumbs for blog posts */ generateBlogBreadcrumbs(postTitle: string, category?: string): Array<{name: string, url?: string}> { const breadcrumbs = [ { name: 'Home', url: this.siteUrl }, { name: 'Blog', url: `${this.siteUrl}/blog` } ]; if (category) { breadcrumbs.push({ name: category, url: `${this.siteUrl}/blog/category/${this.generateSlug(category)}` }); } breadcrumbs.push({ name: postTitle, url: undefined }); return breadcrumbs; } }