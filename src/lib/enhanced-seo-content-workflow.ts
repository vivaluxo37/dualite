import { Task } from './Task' /** * Enhanced SEO Content Workflow Orchestrator * Integrates all SEO AI agents for end-to-end content creation and optimization */ export interface SEOContentWorkflowConfig { projectId: string targetKeywords?: string[] contentStrategy?: 'blog' | 'pillar' | 'cluster' | 'local' optimizationLevel?: 'basic' | 'advanced' | 'enterprise' publishingSchedule?: 'immediate' | 'scheduled' | 'manual' qualityThreshold?: number } export interface SEOContentWorkflowResult { success: boolean contentId?: string seoScore?: number keywords?: string[] metaTags?: { title: string description: string keywords: string } structuredData?: any recommendations?: string[] errors?: string[] } export class EnhancedSEOContentWorkflow { private config: SEOContentWorkflowConfig constructor(config: SEOContentWorkflowConfig) { this.config = config } /** * Execute complete SEO content workflow */ async executeFullWorkflow(topic: string, researchData?: any): Promise<SEOContentWorkflowResult> { try { console.log(`üöÄ Starting Enhanced SEO Content Workflow for: ${topic}`) // Phase 1: Research & Planning const planningResult = await this.executeResearchAndPlanning(topic, researchData) if (!planningResult.success) { return { success: false, errors: ['Planning failed'] } } // Phase 2: Content Creation const creationResult = await this.executeContentCreation(topic, planningResult) if (!creationResult.success) { return { success: false, errors: ['Content creation failed'] } } // Phase 3: SEO Optimization const optimizationResult = await this.executeSEOOptimization(creationResult) if (!optimizationResult.success) { return { success: false, errors: ['SEO optimization failed'] } } // Phase 4: Quality Assurance const qualityResult = await this.executeQualityAssurance(optimizationResult) if (!qualityResult.success) { return { success: false, errors: ['Quality assurance failed'] } } // Phase 5: Publishing (if configured) if (this.config.publishingSchedule === 'immediate') { await this.executePublishing(qualityResult) } return { success: true, contentId: qualityResult.contentId, seoScore: qualityResult.seoScore, keywords: optimizationResult.keywords, metaTags: optimizationResult.metaTags, structuredData: optimizationResult.structure?.data?.structuredData || {}, recommendations: qualityResult.recommendations } } catch (error) { console.error('‚ùå Enhanced SEO Content Workflow failed:', error) return { success: false, errors: [error instanceof Error ? error.message : 'Unknown error'] } } } /** * Phase 1: Research & Planning */ private async executeResearchAndPlanning(topic: string, _researchData?: any) { console.log('üìä Phase 1: Research & Planning') // Use search-specialist for competitive research const searchTask = new Task({ description: 'Competitive research and gap analysis', prompt: `Use search-specialist to conduct comprehensive research on "${topic}" including: - Competitive analysis of top 3 ranking pages - Content gap identification - Search intent analysis - Related questions and topics - Statistical data and trends Provide structured research data for content planning.`, subagent_type: 'search-specialist' }) const searchResult = await searchTask.execute() // Use seo-content-planner for content strategy const planningTask = new Task({ description: 'Content planning and topic clustering', prompt: `Use seo-content-planner to create a comprehensive content strategy for "${topic}" based on research data: ${JSON.stringify(searchResult, null, 2)} Create: - Topic cluster structure - Content outline with H1-H6 headers - Search intent mapping - Internal linking strategy - Content calendar recommendations - Supporting content ideas`, subagent_type: 'seo-content-planner' }) const planningResult = await planningTask.execute() // Use seo-keyword-strategist for keyword strategy const keywordTask = new Task({ description: 'Keyword strategy development', prompt: `Use seo-keyword-strategist to analyze and develop keyword strategy for "${topic}": ${JSON.stringify(planningResult, null, 2)} Provide: - Primary and secondary keywords - Semantic variations and LSI keywords - Keyword density recommendations - Entity analysis - Over-optimization prevention guidelines`, subagent_type: 'seo-keyword-strategist' }) const keywordResult = await keywordTask.execute() return { success: true, research: searchResult, planning: planningResult, keywords: keywordResult } } /** * Phase 2: Content Creation */ private async executeContentCreation(topic: string, planningData: any) { console.log('‚úçÔ∏è Phase 2: Content Creation') // Use seo-content-writer for main content const contentTask = new Task({ description: 'SEO-optimized content creation', prompt: `Use seo-content-writer to create comprehensive SEO content for "${topic}": ${JSON.stringify(planningData, null, 2)} Requirements: - Create comprehensive, engaging content - Integrate keywords naturally - Include E-E-A-T signals - Add FAQ section - Create scannable structure - Include internal linking suggestions - Optimize for featured snippets`, subagent_type: 'seo-content-writer' }) const contentResult = await contentTask.execute() // Use seo-meta-optimizer for metadata const metaTask = new Task({ description: 'Meta tag optimization', prompt: `Use seo-meta-optimizer to create optimized metadata for "${topic}": ${JSON.stringify(contentResult, null, 2)} Create: - SEO-optimized title (50-60 characters) - Compelling meta description (150-160 characters) - SEO-friendly URL structure - Open Graph tags - Twitter Card optimization - A/B test variations`, subagent_type: 'seo-meta-optimizer' }) const metaResult = await metaTask.execute() return { success: true, content: contentResult, metadata: metaResult } } /** * Phase 3: SEO Optimization */ private async executeSEOOptimization(contentData: any) { console.log('üîç Phase 3: SEO Optimization') // Use seo-structure-architect for content structure const structureTask = new Task({ description: 'Content structure optimization', prompt: `Use seo-structure-architect to optimize content structure: ${JSON.stringify(contentData, null, 2)} Optimize: - Header hierarchy (H1-H6) - Schema markup implementation - Internal linking structure - Table of contents - Jump links - Featured snippet formatting`, subagent_type: 'seo-structure-architect' }) const structureResult = await structureTask.execute() // Use seo-snippet-hunter for snippet optimization const snippetTask = new Task({ description: 'Featured snippet optimization', prompt: `Use seo-snippet-hunter to optimize for featured snippets: ${JSON.stringify(structureResult, null, 2)} Create: - Paragraph snippet optimization - List and table snippet formatting - FAQ schema markup - People Also Ask optimization - Question-answer pairs`, subagent_type: 'seo-snippet-hunter' }) const snippetResult = await snippetTask.execute() // Use seo-authority-builder for E-E-A-T optimization const authorityTask = new Task({ description: 'E-E-A-T signal optimization', prompt: `Use seo-authority-builder to enhance E-E-A-T signals: ${JSON.stringify(snippetResult, null, 2)} Enhance: - Experience signals - Expertise demonstration - Authority indicators - Trust signals - Author credibility - Schema markup for authority`, subagent_type: 'seo-authority-builder' }) const authorityResult = await authorityTask.execute() return { success: true, structure: structureResult, snippets: snippetResult, authority: authorityResult, keywords: contentData.keywords || [], metaTags: contentData.metadata || {} } } /** * Phase 4: Quality Assurance */ private async executeQualityAssurance(optimizedData: any) { console.log('‚úÖ Phase 4: Quality Assurance') // Use seo-content-auditor for content quality const auditTask = new Task({ description: 'Content quality audit', prompt: `Use seo-content-auditor to audit content quality: ${JSON.stringify(optimizedData, null, 2)} Audit: - Content depth and comprehensiveness - E-E-A-T signal strength - Readability and user experience - Keyword usage and semantic relevance - Technical SEO compliance - Mobile optimization`, subagent_type: 'seo-content-auditor' }) const auditResult = await auditTask.execute() // Use seo-cannibalization-detector for cannibalization check const cannibalizationTask = new Task({ description: 'Content cannibalization analysis', prompt: `Use seo-cannibalization-detector to check for content cannibalization: ${JSON.stringify(optimizedData, null, 2)} Analyze: - Keyword overlap with existing content - Topic similarity analysis - Search intent conflicts - Internal linking conflicts - Differentiation opportunities`, subagent_type: 'seo-cannibalization-detector' }) const cannibalizationResult = await cannibalizationTask.execute() // Calculate SEO score and generate recommendations const seoScore = this.calculateSEOScore(auditResult, cannibalizationResult) const recommendations = this.generateRecommendations(auditResult, cannibalizationResult) return { success: true, contentId: optimizedData.contentId, seoScore, audit: auditResult, cannibalization: cannibalizationResult, recommendations } } /** * Phase 5: Publishing */ private async executePublishing(qualityData: any) { console.log('üöÄ Phase 5: Publishing') // Use content-marketer for publishing strategy const publishingTask = new Task({ description: 'Content publishing and distribution', prompt: `Use content-marketer to create publishing strategy: ${JSON.stringify(qualityData, null, 2)} Create: - Publishing schedule - Distribution strategy - Social media promotion - Email marketing integration - Performance tracking setup`, subagent_type: 'content-marketer' }) const publishingResult = await publishingTask.execute() return publishingResult } /** * Calculate SEO score based on quality metrics */ private calculateSEOScore(auditResult: any, cannibalizationResult: any): number { // Implement SEO scoring algorithm const contentScore = auditResult.contentDepth || 0 const readabilityScore = auditResult.readability || 0 const technicalScore = auditResult.technicalSEO || 0 const cannibalizationScore = cannibalizationResult.risk === 'low' ? 100 : 50 return Math.round((contentScore + readabilityScore + technicalScore + cannibalizationScore) / 4) } /** * Generate improvement recommendations */ private generateRecommendations(auditResult: any, cannibalizationResult: any): string[] { const recommendations: string[] = [] if (auditResult.contentDepth < 80) { recommendations.push('Expand content depth and comprehensiveness') } if (auditResult.readability < 70) { recommendations.push('Improve readability and user experience') } if (cannibalizationResult.risk === 'high') { recommendations.push('Address content cannibalization issues') } return recommendations } /** * Execute specific SEO improvement task */ async executeImprovement(contentId: string, improvementType: string): Promise<SEOContentWorkflowResult> { switch (improvementType) { case 'refresh': return await this.executeContentRefresh(contentId) case 'meta-optimization': return await this.executeMetaOptimization(contentId) case 'structure-optimization': return await this.executeStructureOptimization(contentId) default: return { success: false, errors: ['Unknown improvement type'] } } } /** * Content refresh workflow */ private async executeContentRefresh(contentId: string): Promise<SEOContentWorkflowResult> { const refreshTask = new Task({ description: 'Content refresh optimization', prompt: `Use seo-content-refresher to refresh and update content with ID "${contentId}": Analyze and update: - Outdated statistics and data - Content decay indicators - Trend integration opportunities - Freshness signals - Competitor updates`, subagent_type: 'seo-content-refresher' }) const refreshResult = await refreshTask.execute() return { success: true, contentId, recommendations: refreshResult.data?.recommendations || [] } } /** * Meta optimization workflow */ private async executeMetaOptimization(contentId: string): Promise<SEOContentWorkflowResult> { const metaTask = new Task({ description: 'Meta tag re-optimization', prompt: `Use seo-meta-optimizer to re-optimize metadata for content ID "${contentId}": Re-optimize: - Title tags for CTR improvement - Meta descriptions for engagement - URL structure - Open Graph tags - Social sharing optimization`, subagent_type: 'seo-meta-optimizer' }) const metaResult = await metaTask.execute() return { success: true, contentId, metaTags: metaResult.data?.metaTags || {}, recommendations: metaResult.data?.recommendations || [] } } /** * Structure optimization workflow */ private async executeStructureOptimization(contentId: string): Promise<SEOContentWorkflowResult> { const structureTask = new Task({ description: 'Content structure optimization', prompt: `Use seo-structure-architect to optimize content structure for ID "${contentId}": Optimize: - Header hierarchy - Schema markup - Internal linking - Content organization - User experience improvements`, subagent_type: 'seo-structure-architect' }) const structureResult = await structureTask.execute() return { success: true, contentId, structuredData: structureResult.data?.structuredData || {}, recommendations: structureResult.data?.recommendations || [] } } } export default EnhancedSEOContentWorkflow