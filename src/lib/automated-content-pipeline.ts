import { BlogAIAgentIntegration } from './blog-ai-agent-integration' import { Task } from './Task' import { supabase } from './supabase' /** * Automated Content Generation Pipeline * Orchestrates end-to-end SEO content creation and publishing */ export interface ContentPipelineConfig { maxPostsPerDay?: number publishingTimes?: string[] autoPublish?: boolean qualityThreshold?: number enableTrendMonitoring?: boolean enableCompetitorAnalysis?: boolean } export interface PipelineSchedule { id: string topic: string categoryId?: string tags?: string[] targetDate: string priority: 'low' | 'medium' | 'high' status: 'scheduled' | 'in_progress' | 'completed' | 'failed' } export interface ContentPipelineResult { success: boolean postsGenerated?: number postsPublished?: number errors?: string[] insights?: any } export class AutomatedContentPipeline { private blogAI: BlogAIAgentIntegration private config: ContentPipelineConfig private isRunning: boolean = false constructor(config: ContentPipelineConfig = {}) { this.blogAI = new BlogAIAgentIntegration() this.config = { maxPostsPerDay: 3, publishingTimes: ['09:00', '14:00', '18:00'], autoPublish: false, qualityThreshold: 85, enableTrendMonitoring: true, enableCompetitorAnalysis: true, ...config } } /** * Start the automated content pipeline */ async start(): Promise<ContentPipelineResult> { try { console.log('üöÄ Starting Automated Content Pipeline') this.isRunning = true // Step 1: Generate content calendar const calendar = await this.generateContentCalendar() // Step 2: Analyze trends and opportunities const trends = this.config.enableTrendMonitoring ? await this.analyzeTrends() : [] // Step 3: Competitor analysis const competitorInsights = this.config.enableCompetitorAnalysis ? await this.analyzeCompetitors() : [] // Step 4: Execute content generation const generationResult = await this.executeContentGeneration(calendar, trends, competitorInsights) // Step 5: Setup monitoring and optimization if (this.config.autoPublish) { await this.setupAutomatedPublishing() } this.isRunning = false return { success: true, postsGenerated: generationResult.postsGenerated, postsPublished: generationResult.postsPublished, insights: { calendar, trends, competitorInsights, generationMetrics: generationResult.metrics } } } catch (error) { this.isRunning = false console.error('‚ùå Automated Content Pipeline failed:', error) return { success: false, errors: [error instanceof Error ? error.message : 'Unknown error'] } } } /** * Generate comprehensive content calendar */ private async generateContentCalendar(): Promise<PipelineSchedule[]> { console.log('üìÖ Generating content calendar') const calendarTask = new Task({ description: 'Generate 3-month SEO content calendar', prompt: `Use seo-content-planner to create a comprehensive 3-month content calendar for a forex broker review blog. Content Categories: 1. Forex Trading Education (30%) - Trading basics - Technical analysis - Fundamental analysis - Risk management - Trading psychology 2. Broker Reviews (25%) - Detailed broker analysis - Platform reviews - Regulatory updates - Comparison guides 3. Market Analysis (20%) - Daily/weekly market analysis - Economic calendar impact - Currency pair analysis - Market sentiment 4. Trading Strategies (15%) - Strategy guides - System development - Backtesting results - Performance optimization 5. Technology & Tools (10%) - Trading platform reviews - EA and algorithm reviews - Mobile trading apps - Analytical tools Requirements: - 12-15 posts per month - Strategic topic clustering - Internal linking strategy - Seasonal and event-based content - Content freshness planning Output format: Array of scheduled posts with: - topic - targetKeywords - contentType - priority - estimatedWordCount - targetPublishDate - categoryAssignment - relatedTopics`, subagent_type: 'seo-content-planner' }) const calendarResult = await calendarTask.execute() // Convert to pipeline schedule format const schedules: PipelineSchedule[] = (calendarResult.data?.calendar || []).map((item: any, index: number) => ({ id: `schedule_${index}`, topic: item.topic, categoryId: item.categoryAssignment, tags: item.relatedTopics || [], targetDate: item.targetPublishDate, priority: item.priority, status: 'scheduled' })) // Save calendar to database await this.saveContentCalendar(schedules) return schedules } /** * Analyze current trends for content opportunities */ private async analyzeTrends(): Promise<any[]> { console.log('üìà Analyzing market trends') const trendsTask = new Task({ description: 'Analyze forex trading trends', prompt: `Use search-specialist to analyze current forex trading trends and content opportunities. Research Areas: - Market volatility patterns - Regulatory changes (FCA, CySEC, ASIC, etc.) - Trading technology trends - Economic indicators affecting forex - Trader behavior shifts - Emerging markets - Cryptocurrency impact on forex For each trend, provide: - Trend name and description - Impact level (high/medium/low) - Content opportunities - Target keywords - Timeline considerations - Competitive landscape Focus on actionable insights for content creation.`, subagent_type: 'search-specialist' }) const trendsResult = await trendsTask.execute() return trendsResult.data?.trends || [] } /** * Analyze competitor content strategies */ private async analyzeCompetitors(): Promise<any[]> { console.log('üîç Analyzing competitor content strategies') const competitorTask = new Task({ description: 'Competitor content analysis', prompt: `Use search-specialist to analyze top forex broker review competitors' content strategies. Analyze competitors like: - ForexPeaceArmy - BrokerChooser - Investopedia (forex section) - DailyForex - 100ForexBrokers - FXEmpire - FXStreet Analysis Areas: - Content gaps and opportunities - Top performing content types - Keyword targeting strategies - Content frequency and timing - Social media integration - User engagement strategies - Technical SEO implementation Provide: - Competitor strengths and weaknesses - Content gap opportunities - Keyword opportunities - Differentiation strategies - Content format preferences`, subagent_type: 'search-specialist' }) const competitorResult = await competitorTask.execute() return competitorResult.data?.insights || [] } /** * Execute content generation based on calendar and insights */ private async executeContentGeneration(calendar: PipelineSchedule[], _trends: any[], _competitorInsights: any[]) { console.log('‚úçÔ∏è Executing content generation') let postsGenerated = 0 let postsPublished = 0 const metrics: any = { totalAttempts: 0, successful: 0, failed: 0, averageSEOScore: 0, topPerformingCategories: {} } // Filter scheduled posts for today const today = new Date().toISOString().split('T')[0] const todayPosts = calendar.filter(post => post.targetDate.split('T')[0] === today) // Limit posts per day const postsToGenerate = todayPosts.slice(0, this.config.maxPostsPerDay) for (const schedule of postsToGenerate) { try { metrics.totalAttempts++ // Update status to in progress await this.updateScheduleStatus(schedule.id, 'in_progress') // Generate blog post with AI agents const result = await this.blogAI.generateBlogPost({ topic: schedule.topic, categoryId: schedule.categoryId, tags: schedule.tags, publishImmediately: this.config.autoPublish }) if (result.success) { metrics.successful++ postsGenerated++ if (this.config.autoPublish) { postsPublished++ } // Update status to completed await this.updateScheduleStatus(schedule.id, 'completed') // Track category performance if (schedule.categoryId) { metrics.topPerformingCategories[schedule.categoryId] = (metrics.topPerformingCategories[schedule.categoryId] || 0) + 1 } console.log(`‚úÖ Generated: ${schedule.topic}`) } else { metrics.failed++ await this.updateScheduleStatus(schedule.id, 'failed') console.error(`‚ùå Failed to generate: ${schedule.topic}`, result.errors) } } catch (error) { metrics.failed++ await this.updateScheduleStatus(schedule.id, 'failed') console.error(`‚ùå Error generating ${schedule.topic}:`, error) } } metrics.averageSEOScore = metrics.successful > 0 ? 85 : 0 // Placeholder return { postsGenerated, postsPublished, metrics } } /** * Setup automated publishing schedule */ private async setupAutomatedPublishing() { console.log('‚è∞ Setting up automated publishing') // This would integrate with a scheduling system // For now, we'll log the configuration console.log('Publishing configuration:', { maxPostsPerDay: this.config.maxPostsPerDay, publishingTimes: this.config.publishingTimes, qualityThreshold: this.config.qualityThreshold }) } /** * Generate and publish trend-based content */ async generateTrendBasedContent(): Promise<ContentPipelineResult> { console.log('üìà Generating trend-based content') try { // Get trending topics const trendingTopics = await this.blogAI.generateTrendBasedIdeas() if (!trendingTopics || trendingTopics.length === 0) { return { success: false, errors: ['No trending topics found'] } } // Generate content for top trending topics const topTopics = trendingTopics.slice(0, 3) let postsGenerated = 0 for (const topic of topTopics) { try { const result = await this.blogAI.generateBlogPost({ topic: typeof topic === 'string' ? topic : ((topic as any).title || topic), targetKeywords: typeof topic === 'string' ? [topic] : ((topic as any).keywords || []), featured: true, publishImmediately: this.config.autoPublish }) if (result.success) { postsGenerated++ console.log(`‚úÖ Generated trend-based post: ${typeof topic === 'string' ? topic : ((topic as any).title || topic)}`) } } catch (error) { console.error(`‚ùå Failed to generate trend-based post: ${error}`) } } return { success: true, postsGenerated, postsPublished: this.config.autoPublish ? postsGenerated : 0, insights: { trendingTopics: topTopics } } } catch (error) { console.error('‚ùå Trend-based content generation failed:', error) return { success: false, errors: [error instanceof Error ? error.message : 'Unknown error'] } } } /** * Content audit and optimization cycle */ async executeContentOptimizationCycle(): Promise<ContentPipelineResult> { console.log('üîç Executing content optimization cycle') try { // Get underperforming posts const { data: underperformingPosts, error } = await supabase .from('blog_posts') .select('id, title, view_count') .lt('view_count', 100) .order('published_at', { ascending: false }) .limit(10) if (error) { return { success: false, errors: [error.message] } } let postsOptimized = 0 for (const post of underperformingPosts) { try { const result = await this.blogAI.optimizeExistingBlogPost(post.id) if (result.success) { postsOptimized++ console.log(`‚úÖ Optimized: ${post.title}`) } } catch (error) { console.error(`‚ùå Failed to optimize ${post.title}:`, error) } } return { success: true, postsGenerated: 0, postsPublished: 0, insights: { postsOptimized, totalAudited: underperformingPosts.length } } } catch (error) { console.error('‚ùå Content optimization cycle failed:', error) return { success: false, errors: [error instanceof Error ? error.message : 'Unknown error'] } } } /** * Get pipeline status and metrics */ async getPipelineStatus(): Promise<any> { const { data: schedules, error } = await supabase .from('content_pipeline_schedules') .select('*') .order('target_date', { ascending: true }) if (error) { return { error: error.message } } const metrics = { totalScheduled: schedules.length, scheduled: schedules.filter(s => s.status === 'scheduled').length, inProgress: schedules.filter(s => s.status === 'in_progress').length, completed: schedules.filter(s => s.status === 'completed').length, failed: schedules.filter(s => s.status === 'failed').length, isRunning: this.isRunning } return { schedules, metrics } } /** * Private helper methods */ private async saveContentCalendar(schedules: PipelineSchedule[]) { const { error } = await supabase .from('content_pipeline_schedules') .insert(schedules.map(s => ({ id: s.id, topic: s.topic, category_id: s.categoryId, tags: s.tags, target_date: s.targetDate, priority: s.priority, status: s.status, created_at: new Date().toISOString() }))) if (error) { console.error('Failed to save content calendar:', error) } } private async updateScheduleStatus(scheduleId: string, status: string) { await supabase .from('content_pipeline_schedules') .update({ status, updated_at: new Date().toISOString() }) .eq('id', scheduleId) } } export default AutomatedContentPipeline