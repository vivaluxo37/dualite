// Master Workflow Orchestration Script // This script orchestrates the entire SEO content workflow from scraping to deployment import { BrokerScrapingService } from './broker-scraping'; import { KeywordResearchAgent } from './keyword-research'; import { ContentPlanningAgent } from './content-planning'; import { ContentGenerationAgent } from './content-generation'; import { SEOOptimizationAgent } from './seo-optimization'; import { QualityAssuranceAgent } from './quality-assurance'; import AutomatedDeploymentService from './automated-deployment'; export interface WorkflowConfig { supabaseProjectId: string; brokerNames: string[]; contentTypes: ('guide' | 'review' | 'comparison' | 'tutorial' | 'news')[]; qualityThreshold: number; maxConcurrentProcesses: number; enableDeployment: boolean; retryFailedSteps: boolean; notificationSettings: { email?: string; webhook?: string; slack?: string; }; } export interface WorkflowExecution { id: string; config: WorkflowConfig; status: 'pending' | 'running' | 'completed' | 'failed' | 'paused'; startTime: Date; endTime?: Date; progress: WorkflowProgress; results: WorkflowResults; errors: WorkflowError[]; logs: WorkflowLog[]; } export interface WorkflowProgress { totalSteps: number; completedSteps: number; currentStep: string; stepProgress: number; // 0-100 brokersProcessed: number; totalBrokers: number; contentGenerated: number; contentOptimized: number; contentPublished: number; } export interface WorkflowResults { brokerData: { [brokerName: string]: any }; keywordsGenerated: { [brokerName: string]: any[] }; contentPlans: { [brokerName: string]: any[] }; generatedContent: { [brokerName: string]: any[] }; optimizedContent: { [brokerName: string]: any[] }; qualityReports: { [brokerName: string]: any[] }; publishedContent: { [brokerName: string]: any[] }; summary: WorkflowSummary; } export interface WorkflowSummary { totalBrokersProcessed: number; totalKeywordsResearched: number; totalContentPiecesGenerated: number; totalContentPiecesOptimized: number; totalContentPiecesPublished: number; averageQualityScore: number; averageSEOScore: number; totalProcessingTime: number; successRate: number; errorsEncountered: number; } export interface WorkflowError { timestamp: Date; step: string; brokerName?: string; error: string; severity: 'low' | 'medium' | 'high' | 'critical'; retryable: boolean; retryCount: number; resolved: boolean; } export interface WorkflowLog { timestamp: Date; level: 'info' | 'warn' | 'error' | 'debug'; step: string; message: string; brokerName?: string; metadata?: any; } export class WorkflowOrchestrator { private config: WorkflowConfig; private execution: WorkflowExecution; private scrapingService: BrokerScrapingService; private keywordAgent: KeywordResearchAgent; private planningAgent: ContentPlanningAgent; private generationAgent: ContentGenerationAgent; private seoAgent: SEOOptimizationAgent; private qaAgent: QualityAssuranceAgent; private deploymentService: AutomatedDeploymentService; constructor(config: WorkflowConfig) { this.config = config; this.execution = this.initializeExecution(); // Initialize agents this.scrapingService = new BrokerScrapingService(); this.keywordAgent = new KeywordResearchAgent(config.supabaseProjectId); this.planningAgent = new ContentPlanningAgent(config.supabaseProjectId); this.generationAgent = new ContentGenerationAgent(config.supabaseProjectId); this.seoAgent = new SEOOptimizationAgent(config.supabaseProjectId); this.qaAgent = new QualityAssuranceAgent(config.supabaseProjectId); // Initialize deployment service this.deploymentService = new AutomatedDeploymentService({ outputDir: 'src/pages', templateDir: 'src/templates', generateRoutes: true, updateSitemap: true, deployToProduction: config.enableDeployment }); } private initializeExecution(): WorkflowExecution { return { id: `workflow_${Date.now()}`, config: this.config, status: 'pending', startTime: new Date(), progress: { totalSteps: 7, // Total workflow steps completedSteps: 0, currentStep: '', stepProgress: 0, brokersProcessed: 0, totalBrokers: this.config.brokerNames.length, contentGenerated: 0, contentOptimized: 0, contentPublished: 0 }, results: { brokerData: {}, keywordsGenerated: {}, contentPlans: {}, generatedContent: {}, optimizedContent: {}, qualityReports: {}, publishedContent: {}, summary: this.createEmptySummary() }, errors: [], logs: [] }; } private createEmptySummary(): WorkflowSummary { return { totalBrokersProcessed: 0, totalKeywordsResearched: 0, totalContentPiecesGenerated: 0, totalContentPiecesOptimized: 0, totalContentPiecesPublished: 0, averageQualityScore: 0, averageSEOScore: 0, totalProcessingTime: 0, successRate: 100, errorsEncountered: 0 }; } async executeWorkflow(): Promise<WorkflowExecution> { try { this.log('info', 'workflow_start', 'Starting SEO workflow execution'); this.execution.status = 'running'; // Step 1: Broker Data Collection await this.executeBrokerDataCollection(); // Step 2: Keyword Research await this.executeKeywordResearch(); // Step 3: Content Planning await this.executeContentPlanning(); // Step 4: Content Generation await this.executeContentGeneration(); // Step 5: SEO Optimization await this.executeSEOOptimization(); // Step 6: Quality Assurance await this.executeQualityAssurance(); // Step 7: Content Deployment (if enabled) if (this.config.enableDeployment) { await this.executeContentDeployment(); } // Complete workflow await this.completeWorkflow(); return this.execution; } catch (error) { this.log('error', 'workflow_execution', `Workflow execution failed: ${error.message}`, undefined, { error }); this.execution.status = 'failed'; this.execution.endTime = new Date(); throw error; } } private async executeBrokerDataCollection(): Promise<void> { this.updateProgress('broker_data_collection', 0, 'Starting broker data collection'); const brokerData: { [brokerName: string]: any } = {}; for (const brokerName of this.config.brokerNames) { try { this.log('info', 'broker_scraping', `Scraping data for ${brokerName}`, brokerName); const data = await this.scrapingService.scrapeBroker(brokerName); if (data) { brokerData[brokerName] = data; this.log('info', 'broker_scraping_success', `Successfully scraped data for ${brokerName}`, brokerName); } else { this.log('warn', 'broker_scraping_failed', `Failed to scrape data for ${brokerName}`, brokerName); } // Update progress const progress = ((Object.keys(brokerData).length + 1) / this.config.brokerNames.length) * 100; this.updateProgress('broker_data_collection', progress, `Processed ${brokerName}`); } catch (error) { this.log('error', 'broker_scraping_error', `Error scraping ${brokerName}: ${error.message}`, brokerName); this.addError('broker_data_collection', brokerName, error.message, 'medium', true); } } this.execution.results.brokerData = brokerData; this.execution.progress.completedSteps = 1; this.log('info', 'broker_data_collection_complete', `Broker data collection completed for ${Object.keys(brokerData).length} brokers`); } private async executeKeywordResearch(): Promise<void> { this.updateProgress('keyword_research', 0, 'Starting keyword research'); const keywordsGenerated: { [brokerName: string]: any[] } = {}; let totalKeywords = 0; for (const [brokerName, brokerData] of Object.entries(this.execution.results.brokerData)) { try { this.log('info', 'keyword_research', `Researching keywords for ${brokerName}`, brokerName); const keywords = await this.keywordAgent.researchBrokerKeywords(brokerName, brokerData.id || brokerName); if (keywords && keywords.length > 0) { keywordsGenerated[brokerName] = keywords; totalKeywords += keywords.length; this.log('info', 'keyword_research_success', `Generated ${keywords.length} keywords for ${brokerName}`, brokerName); } else { this.log('warn', 'keyword_research_failed', `No keywords generated for ${brokerName}`, brokerName); } // Update progress const progress = ((Object.keys(keywordsGenerated).length + 1) / Object.keys(this.execution.results.brokerData).length) * 100; this.updateProgress('keyword_research', progress, `Researched keywords for ${brokerName}`); } catch (error) { this.log('error', 'keyword_research_error', `Error researching keywords for ${brokerName}: ${error.message}`, brokerName); this.addError('keyword_research', brokerName, error.message, 'medium', true); } } this.execution.results.keywordsGenerated = keywordsGenerated; this.execution.results.summary.totalKeywordsResearched = totalKeywords; this.execution.progress.completedSteps = 2; this.log('info', 'keyword_research_complete', `Keyword research completed. Total keywords: ${totalKeywords}`); } private async executeContentPlanning(): Promise<void> { this.updateProgress('content_planning', 0, 'Starting content planning'); const contentPlans: { [brokerName: string]: any[] } = {}; for (const [brokerName, brokerData] of Object.entries(this.execution.results.brokerData)) { try { this.log('info', 'content_planning', `Planning content for ${brokerName}`, brokerName); const brokerKeywords = this.execution.results.keywordsGenerated[brokerName] || []; const keywordClusters = await this.keywordAgent.getKeywordClusters(brokerData.id || brokerName, brokerKeywords); const plans: any[] = []; for (const contentType of this.config.contentTypes) { for (const cluster of keywordClusters.slice(0, 3)) { // Limit to 3 clusters per content type try { const outline = await this.planningAgent.createContentOutline( brokerData.id || brokerName, cluster.cluster_name, cluster.keywords, contentType ); if (outline) { plans.push(outline); } } catch (error) { this.log('warn', 'content_planning_outline_failed', `Failed to create outline for ${contentType} - ${cluster.cluster_name}`, brokerName); } } } if (plans.length > 0) { contentPlans[brokerName] = plans; this.log('info', 'content_planning_success', `Created ${plans.length} content plans for ${brokerName}`, brokerName); } else { this.log('warn', 'content_planning_failed', `No content plans created for ${brokerName}`, brokerName); } // Update progress const progress = ((Object.keys(contentPlans).length + 1) / Object.keys(this.execution.results.brokerData).length) * 100; this.updateProgress('content_planning', progress, `Planned content for ${brokerName}`); } catch (error) { this.log('error', 'content_planning_error', `Error planning content for ${brokerName}: ${error.message}`, brokerName); this.addError('content_planning', brokerName, error.message, 'medium', true); } } this.execution.results.contentPlans = contentPlans; this.execution.progress.completedSteps = 3; this.log('info', 'content_planning_complete', `Content planning completed for ${Object.keys(contentPlans).length} brokers`); } private async executeContentGeneration(): Promise<void> { this.updateProgress('content_generation', 0, 'Starting content generation'); const generatedContent: { [brokerName: string]: any[] } = {}; let totalContentGenerated = 0; for (const [brokerName, brokerData] of Object.entries(this.execution.results.brokerData)) { try { this.log('info', 'content_generation', `Generating content for ${brokerName}`, brokerName); const contentPlans = this.execution.results.contentPlans[brokerName] || []; const brokerKeywords = this.execution.results.keywordsGenerated[brokerName] || []; const generated: any[] = []; for (const plan of contentPlans.slice(0, 5)) { // Limit to 5 content pieces per broker try { const request = { outline: plan, brokerData, targetKeywords: brokerKeywords.slice(0, 10).map(k => k.keyword), tone: 'professional' as 'professional' | 'conversational' | 'educational' | 'promotional', include_structured_data: true, word_count_target: plan.target_word_count || 1500 }; const content = await this.generationAgent.generateContent(request); if (content) { generated.push(content); totalContentGenerated++; } } catch (error) { this.log('warn', 'content_generation_failed', `Failed to generate content for ${plan.title}`, brokerName); } } if (generated.length > 0) { generatedContent[brokerName] = generated; this.log('info', 'content_generation_success', `Generated ${generated.length} content pieces for ${brokerName}`, brokerName); } else { this.log('warn', 'content_generation_failed', `No content generated for ${brokerName}`, brokerName); } // Update progress const progress = ((Object.keys(generatedContent).length + 1) / Object.keys(this.execution.results.brokerData).length) * 100; this.updateProgress('content_generation', progress, `Generated content for ${brokerName}`, totalContentGenerated); } catch (error) { this.log('error', 'content_generation_error', `Error generating content for ${brokerName}: ${error.message}`, brokerName); this.addError('content_generation', brokerName, error.message, 'high', true); } } this.execution.results.generatedContent = generatedContent; this.execution.results.summary.totalContentPiecesGenerated = totalContentGenerated; this.execution.progress.completedSteps = 4; this.log('info', 'content_generation_complete', `Content generation completed. Total pieces: ${totalContentGenerated}`); } private async executeSEOOptimization(): Promise<void> { this.updateProgress('seo_optimization', 0, 'Starting SEO optimization'); const optimizedContent: { [brokerName: string]: any[] } = {}; let totalOptimized = 0; for (const [brokerName, contentPieces] of Object.entries(this.execution.results.generatedContent)) { try { this.log('info', 'seo_optimization', `Optimizing SEO for ${brokerName}`, brokerName); const brokerKeywords = this.execution.results.keywordsGenerated[brokerName] || []; const optimized: any[] = []; for (const content of contentPieces) { try { const request = { content: content.content, title: content.title, content_type: content.content_type, target_keywords: brokerKeywords.slice(0, 5).map(k => k.keyword), broker_data: this.execution.results.brokerData[brokerName], current_url: `/brokers/${brokerName.toLowerCase().replace(/\s+/g, '-')}`, include_structured_data: true, optimize_for_snippets: true }; const optimization = await this.seoAgent.optimizeContent(request); if (optimization) { optimized.push({ ...content, seo_optimization: optimization }); totalOptimized++; } } catch (error) { this.log('warn', 'seo_optimization_failed', `Failed to optimize SEO for ${content.title}`, brokerName); } } if (optimized.length > 0) { optimizedContent[brokerName] = optimized; this.log('info', 'seo_optimization_success', `Optimized SEO for ${optimized.length} content pieces for ${brokerName}`, brokerName); } else { this.log('warn', 'seo_optimization_failed', `No SEO optimization completed for ${brokerName}`, brokerName); } // Update progress const progress = ((Object.keys(optimizedContent).length + 1) / Object.keys(this.execution.results.generatedContent).length) * 100; this.updateProgress('seo_optimization', progress, `Optimized SEO for ${brokerName}`, totalOptimized); } catch (error) { this.log('error', 'seo_optimization_error', `Error optimizing SEO for ${brokerName}: ${error.message}`, brokerName); this.addError('seo_optimization', brokerName, error.message, 'medium', true); } } this.execution.results.optimizedContent = optimizedContent; this.execution.results.summary.totalContentPiecesOptimized = totalOptimized; this.execution.progress.completedSteps = 5; this.log('info', 'seo_optimization_complete', `SEO optimization completed. Total pieces optimized: ${totalOptimized}`); } private async executeQualityAssurance(): Promise<void> { this.updateProgress('quality_assurance', 0, 'Starting quality assurance'); const qualityReports: { [brokerName: string]: any[] } = {}; let totalQualityScore = 0; let totalSEOScore = 0; let qualityCount = 0; for (const [brokerName, contentPieces] of Object.entries(this.execution.results.optimizedContent)) { try { this.log('info', 'quality_assurance', `Performing quality assurance for ${brokerName}`, brokerName); const reports: any[] = []; for (const content of contentPieces) { try { const request = { content: content.content, title: content.title, content_type: content.content_type, target_keywords: content.seo_optimization?.focus_keywords || [], broker_data: this.execution.results.brokerData[brokerName], content_metadata: content.metadata, compliance_requirements: ['financial_services', 'broker_disclosure'], quality_threshold: this.config.qualityThreshold }; const qa = await this.qaAgent.performQualityAssurance(request); if (qa) { reports.push(qa); totalQualityScore += qa.overall_score; totalSEOScore += qa.seo_compliance?.meta_optimization || 0; qualityCount++; } } catch (error) { this.log('warn', 'quality_assurance_failed', `Failed QA for ${content.title}`, brokerName); } } if (reports.length > 0) { qualityReports[brokerName] = reports; this.log('info', 'quality_assurance_success', `Completed QA for ${reports.length} content pieces for ${brokerName}`, brokerName); } else { this.log('warn', 'quality_assurance_failed', `No QA completed for ${brokerName}`, brokerName); } // Update progress const progress = ((Object.keys(qualityReports).length + 1) / Object.keys(this.execution.results.optimizedContent).length) * 100; this.updateProgress('quality_assurance', progress, `Quality assurance completed for ${brokerName}`); } catch (error) { this.log('error', 'quality_assurance_error', `Error in QA for ${brokerName}: ${error.message}`, brokerName); this.addError('quality_assurance', brokerName, error.message, 'high', true); } } this.execution.results.qualityReports = qualityReports; this.execution.results.summary.averageQualityScore = qualityCount > 0 ? Math.round(totalQualityScore / qualityCount) : 0; this.execution.results.summary.averageSEOScore = qualityCount > 0 ? Math.round(totalSEOScore / qualityCount) : 0; this.execution.progress.completedSteps = 6; this.log('info', 'quality_assurance_complete', `Quality assurance completed. Average quality score: ${this.execution.results.summary.averageQualityScore}`); } private async executeContentDeployment(): Promise<void> { this.updateProgress('content_deployment', 0, 'Starting content deployment'); const publishedContent: { [brokerName: string]: any[] } = {}; let totalPublished = 0; for (const [brokerName, contentPieces] of Object.entries(this.execution.results.optimizedContent)) { try { this.log('info', 'content_deployment', `Deploying content for ${brokerName}`, brokerName); const qualityReports = this.execution.results.qualityReports[brokerName] || []; const published: any[] = []; for (let i = 0; i < contentPieces.length; i++) { const content = contentPieces[i]; const qa = qualityReports[i]; // Only publish content that passes quality threshold if (qa && qa.overall_score >= this.config.qualityThreshold) { try { const published = await this.deployContent(content, qa, brokerName); if (published) { published.push(published); totalPublished++; } } catch (error) { this.log('warn', 'content_deployment_failed', `Failed to deploy ${content.title}`, brokerName); } } else { this.log('info', 'content_deployment_skipped', `Skipped deploying ${content.title} - quality score ${qa?.overall_score} below threshold ${this.config.qualityThreshold}`, brokerName); } } if (published.length > 0) { publishedContent[brokerName] = published; this.log('info', 'content_deployment_success', `Deployed ${published.length} content pieces for ${brokerName}`, brokerName); } // Update progress const progress = ((Object.keys(publishedContent).length + 1) / Object.keys(this.execution.results.optimizedContent).length) * 100; this.updateProgress('content_deployment', progress, `Deployed content for ${brokerName}`, totalPublished); } catch (error) { this.log('error', 'content_deployment_error', `Error deploying content for ${brokerName}: ${error.message}`, brokerName); this.addError('content_deployment', brokerName, error.message, 'medium', false); } } this.execution.results.publishedContent = publishedContent; this.execution.results.summary.totalContentPiecesPublished = totalPublished; this.execution.progress.completedSteps = 7; this.log('info', 'content_deployment_complete', `Content deployment completed. Total pieces published: ${totalPublished}`); } private async deployContent(content: any, qa: any, brokerName: string): Promise<any> { try { this.log('info', 'content_deploying', `Deploying content: ${content.title}`, brokerName); // Create generated page object for deployment const generatedPage = { brokerId: brokerName.toLowerCase().replace(/\s+/g, '-'), brokerName: brokerName, contentType: content.content_type, content: content.content, title: content.title, description: content.description, seoOptimization: content.seo_optimization, qualityAssurance: qa, metadata: content.metadata || {} }; // Deploy using the automated deployment service const deploymentResult = await this.deploymentService.deployPages([generatedPage]); if (deploymentResult.success && deploymentResult.deployedPages.length > 0) { const deployedContent = { ...content, deployment_info: { deployed_at: new Date().toISOString(), deployment_url: `/brokers/${brokerName.toLowerCase().replace(/\s+/g, '-')}/${content.content_type}`, version: `v${Date.now()}`, status: 'published', deployment_id: deploymentResult.deployedPages[0] }, quality_assurance: qa, deployment_result: deploymentResult }; this.log('info', 'content_deployed', `Successfully deployed: ${content.title}`, brokerName); return deployedContent; } else { throw new Error(`Deployment failed: ${deploymentResult.errors.join(', ')}`); } } catch (error) { this.log('error', 'content_deployment_error', `Failed to deploy content: ${error.message}`, brokerName); throw error; } } private async completeWorkflow(): Promise<void> { this.execution.status = 'completed'; this.execution.endTime = new Date(); // Calculate final summary const processingTime = this.execution.endTime.getTime() - this.execution.startTime.getTime(); this.execution.results.summary.totalProcessingTime = processingTime; this.execution.results.summary.totalBrokersProcessed = Object.keys(this.execution.results.brokerData).length; this.execution.results.summary.errorsEncountered = this.execution.errors.length; this.execution.results.summary.successRate = Math.round( ((this.execution.results.summary.totalBrokersProcessed - this.execution.errors.length) / this.execution.results.summary.totalBrokersProcessed) * 100 ); this.updateProgress('workflow_complete', 100, 'Workflow completed successfully'); this.log('info', 'workflow_complete', `Workflow completed successfully. Summary: ${JSON.stringify(this.execution.results.summary, null, 2)}`); // Send notifications if configured await this.sendNotifications(); } private updateProgress(step: string, progress: number, message: string, additionalProgress?: number): void { this.execution.progress.currentStep = step; this.execution.progress.stepProgress = progress; if (additionalProgress !== undefined) { if (step.includes('generation')) { this.execution.progress.contentGenerated = additionalProgress; } else if (step.includes('optimization')) { this.execution.progress.contentOptimized = additionalProgress; } else if (step.includes('deployment')) { this.execution.progress.contentPublished = additionalProgress; } } this.log('info', 'progress_update', message, undefined, { step, progress, additionalProgress }); } private log(level: 'info' | 'warn' | 'error' | 'debug', step: string, message: string, brokerName?: string, metadata?: any): void { const logEntry: WorkflowLog = { timestamp: new Date(), level, step, message, brokerName, metadata }; this.execution.logs.push(logEntry); // Keep only last 1000 logs to prevent memory issues if (this.execution.logs.length > 1000) { this.execution.logs = this.execution.logs.slice(-1000); } // Console output for real-time monitoring console.log(`[${logEntry.timestamp.toISOString()}] [${level.toUpperCase()}] [${step}] ${brokerName ? `[${brokerName}]` : ''} ${message}`); } private addError(step: string, brokerName: string | undefined, error: string, severity: 'low' | 'medium' | 'high' | 'critical', retryable: boolean): void { const errorEntry: WorkflowError = { timestamp: new Date(), step, brokerName, error, severity, retryable, retryCount: 0, resolved: false }; this.execution.errors.push(errorEntry); // Keep only last 500 errors if (this.execution.errors.length > 500) { this.execution.errors = this.execution.errors.slice(-500); } } private async sendNotifications(): Promise<void> { try { if (!this.config.notificationSettings) return; const summary = this.execution.results.summary; const message = `SEO Workflow completed:\n` + `- Brokers processed: ${summary.totalBrokersProcessed}\n` + `- Content generated: ${summary.totalContentPiecesGenerated}\n` + `- Content published: ${summary.totalContentPiecesPublished}\n` + `- Average quality score: ${summary.averageQualityScore}\n` + `- Success rate: ${summary.successRate}%\n` + `- Processing time: ${Math.round(summary.totalProcessingTime / 1000 / 60)} minutes`; // Send email notification if (this.config.notificationSettings.email) { await this.sendEmailNotification('SEO Workflow Completed', message); } // Send webhook notification if (this.config.notificationSettings.webhook) { await this.sendWebhookNotification(this.config.notificationSettings.webhook, { workflow_id: this.execution.id, status: this.execution.status, summary, message }); } this.log('info', 'notifications_sent', 'Workflow completion notifications sent'); } catch (error) { this.log('error', 'notification_error', `Failed to send notifications: ${error.message}`); } } private async sendEmailNotification(subject: string, body: string): Promise<void> { try { // This would integrate with an email service console.log(`Email notification would be sent: ${subject} - ${body}`); } catch (error) { this.log('error', 'email_notification_error', `Failed to send email: ${error.message}`); } } private async sendWebhookNotification(url: string, data: any): Promise<void> { try { // This would send a webhook notification console.log(`Webhook notification would be sent to ${url}: ${JSON.stringify(data)}`); } catch (error) { this.log('error', 'webhook_notification_error', `Failed to send webhook: ${error.message}`); } } getExecutionStatus(): WorkflowExecution { return { ...this.execution }; } getWorkflowLogs(level?: 'info' | 'warn' | 'error' | 'debug'): WorkflowLog[] { if (level) { return this.execution.logs.filter(log => log.level === level); } return this.execution.logs; } getWorkflowErrors(severity?: 'low' | 'medium' | 'high' | 'critical'): WorkflowError[] { if (severity) { return this.execution.errors.filter(error => error.severity === severity); } return this.execution.errors; } async pauseWorkflow(): Promise<void> { if (this.execution.status === 'running') { this.execution.status = 'paused'; this.log('info', 'workflow_paused', 'Workflow paused by user'); } } async resumeWorkflow(): Promise<void> { if (this.execution.status === 'paused') { this.execution.status = 'running'; this.log('info', 'workflow_resumed', 'Workflow resumed by user'); } } async stopWorkflow(): Promise<void> { if (this.execution.status === 'running' || this.execution.status === 'paused') { this.execution.status = 'failed'; this.execution.endTime = new Date(); this.log('info', 'workflow_stopped', 'Workflow stopped by user'); } } } // Export utility functions for easy workflow execution export async function executeSEOWorkflow(config: WorkflowConfig): Promise<WorkflowExecution> { const orchestrator = new WorkflowOrchestrator(config); return await orchestrator.executeWorkflow(); } export function createDefaultWorkflowConfig(supabaseProjectId: string, brokerNames: string[]): WorkflowConfig { return { supabaseProjectId, brokerNames, contentTypes: ['review', 'guide', 'comparison'], qualityThreshold: 75, maxConcurrentProcesses: 3, enableDeployment: false, retryFailedSteps: true, notificationSettings: { // Configure notifications as needed } }; }