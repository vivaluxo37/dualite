import { useEffect } from 'react'; interface SEOProps { title: string; description: string; keywords?: string; canonicalUrl?: string; ogType?: string; ogTitle?: string; ogDescription?: string; ogImage?: string; twitterCard?: string; twitterTitle?: string; twitterDescription?: string; structuredData?: any; additionalMetaTags?: Array<{ name?: string; property?: string; content: string }>; hreflang?: Record<string, string>; } export function SEO({ title, description, keywords, canonicalUrl, ogType = 'website', ogTitle, ogDescription, ogImage, twitterCard = 'summary_large_image', twitterTitle, twitterDescription, structuredData, additionalMetaTags, hreflang }: SEOProps) { useEffect(() => { // Update document title document.title = title; // Update or create meta tags const updateMetaTag = (name: string, content: string) => { if (!name || !content) return; let meta = document.querySelector(`meta[name="${name}"]`) || document.querySelector(`meta[property="${name}"]`); if (!meta) { meta = document.createElement('meta'); if (name.startsWith('og:')) { meta.setAttribute('property', name); } else { meta.setAttribute('name', name); } document.head.appendChild(meta); } meta.setAttribute('content', content); }; // Update canonical URL if (canonicalUrl) { let canonical = document.querySelector('link[rel="canonical"]'); if (!canonical) { canonical = document.createElement('link'); canonical.setAttribute('rel', 'canonical'); document.head.appendChild(canonical); } canonical.setAttribute('href', canonicalUrl); } // Update hreflang tags if (hreflang) { // Remove existing hreflang tags document.querySelectorAll('link[rel="alternate"][hreflang]').forEach(tag => tag.remove()); // Add new hreflang tags Object.entries(hreflang).forEach(([lang, url]) => { const hreflangTag = document.createElement('link'); hreflangTag.setAttribute('rel', 'alternate'); hreflangTag.setAttribute('hreflang', lang); hreflangTag.setAttribute('href', url); document.head.appendChild(hreflangTag); }); } // Basic meta tags updateMetaTag('description', description); if (keywords) updateMetaTag('keywords', keywords); updateMetaTag('author', 'BrokerAnalysis'); updateMetaTag('robots', 'index, follow'); // Additional meta tags if (additionalMetaTags) { additionalMetaTags.forEach(tag => { if (tag.name) { updateMetaTag(tag.name, tag.content); } else if (tag.property) { updateMetaTag(tag.property, tag.content); } }); } // Open Graph tags updateMetaTag('og:type', ogType); updateMetaTag('og:title', ogTitle || title); updateMetaTag('og:description', ogDescription || description); if (canonicalUrl) updateMetaTag('og:url', canonicalUrl); updateMetaTag('og:site_name', 'BrokerAnalysis'); updateMetaTag('og:locale', 'en_US'); if (ogImage) updateMetaTag('og:image', ogImage); // Twitter Card tags updateMetaTag('twitter:card', twitterCard); updateMetaTag('twitter:title', twitterTitle || title); updateMetaTag('twitter:description', twitterDescription || description); if (ogImage) updateMetaTag('twitter:image', ogImage); // Structured data if (structuredData) { // Remove existing structured data scripts document.querySelectorAll('script[type="application/ld+json"]').forEach(script => script.remove()); // Add new structured data scripts const structuredDataArray = Array.isArray(structuredData) ? structuredData : [structuredData]; structuredDataArray.forEach(data => { const script = document.createElement('script'); script.setAttribute('type', 'application/ld+json'); script.textContent = JSON.stringify(data); document.head.appendChild(script); }); } // Cleanup on unmount return () => { // Remove all structured data scripts document.querySelectorAll('script[type="application/ld+json"]').forEach(script => script.remove()); }; }, [title, description, keywords, canonicalUrl, ogType, ogTitle, ogDescription, ogImage, twitterCard, twitterTitle, twitterDescription, structuredData, additionalMetaTags]); return null; }