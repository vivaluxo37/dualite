import { useState, useEffect } from 'react' import { useParams, Link } from 'react-router-dom' import { useQuery } from '@tanstack/react-query' import { motion } from 'framer-motion' import { supabase } from '@/lib/supabase' import { BlogCard, BlogList } from '@/components/blog/BlogCard' import { BlogFilter, BlogFilters } from '@/components/blog/BlogFilter' import { BlogSidebar } from '@/components/blog/BlogSidebar' import { BlogSEO } from '@/components/blog/BlogSEO' import { Button } from '@/components/ui/button' import { Badge } from '@/components/ui/badge' import { Card, CardContent } from '@/components/ui/card' import { Loader2, ArrowLeft, Filter, BookOpen, Hash, Calendar, Grid, List } from 'lucide-react' import { BlogPost, BlogCategory, BlogTag } from '@/types' interface BlogCategoryPageProps { type: 'category' | 'tag' } export function BlogCategoryPage({ type }: BlogCategoryPageProps) { const { slug } = useParams<{ slug: string }>() const [currentFilters, setCurrentFilters] = useState<BlogFilters>({ search: '', categoryId: null, tagId: null, sortBy: 'published_at', sortOrder: 'desc', dateFilter: 'all', isFeatured: null }) const [currentPage, setCurrentPage] = useState(1) const postsPerPage = 9 // Fetch category or tag data const { data: categoryData, isLoading: categoryLoading } = useQuery({ queryKey: ['blog-category', slug], queryFn: async () => { if (!slug || type !== 'category') return null const { data, error } = await supabase .from('blog_categories') .select('*') .eq('slug', slug) .single() if (error) throw error return data }, enabled: type === 'category' && !!slug }) const { data: tagData, isLoading: tagLoading } = useQuery({ queryKey: ['blog-tag', slug], queryFn: async () => { if (!slug || type !== 'tag') return null const { data, error } = await supabase .from('blog_tags') .select('*') .eq('slug', slug) .single() if (error) throw error return data }, enabled: type === 'tag' && !!slug }) // Fetch blog posts const fetchBlogPosts = async (filters: BlogFilters, page: number) => { if (!slug) return { posts: [], total: 0, has_more: false } let query = supabase .from('blog_posts') .select('*', { count: 'exact' }) // Apply filters if (filters.search) { query = query.or(`title.ilike.%${filters.search}%,excerpt.ilike.%${filters.search}%,content.ilike.%${filters.search}%`) } // Apply category or tag filter using a simpler approach if (type === 'category' && categoryData?.id) { // First get post IDs for this category const { data: categoryPosts } = await supabase .from('blog_post_categories') .select('post_id') .eq('category_id', categoryData.id) if (categoryPosts && categoryPosts.length > 0) { const postIds = categoryPosts.map(cp => cp.post_id) query = query.in('id', postIds) } else { return { posts: [], total: 0, has_more: false } } } else if (type === 'tag' && tagData?.id) { // First get post IDs for this tag const { data: tagPosts } = await supabase .from('blog_post_tags') .select('post_id') .eq('tag_id', tagData.id) if (tagPosts && tagPosts.length > 0) { const postIds = tagPosts.map(tp => tp.post_id) query = query.in('id', postIds) } else { return { posts: [], total: 0, has_more: false } } } if (filters.isFeatured !== null) { query = query.eq('is_featured', filters.isFeatured) } // Apply date filter if (filters.dateFilter !== 'all') { const now = new Date() let startDate = new Date() switch (filters.dateFilter) { case 'today': startDate.setHours(0, 0, 0, 0) break case 'week': startDate.setDate(now.getDate() - 7) break case 'month': startDate.setMonth(now.getMonth() - 1) break case 'year': startDate.setFullYear(now.getFullYear() - 1) break } query = query.gte('published_at', startDate.toISOString()) } // Apply sorting const orderDirection = filters.sortOrder === 'desc' ? false : true query = query.order(filters.sortBy, { ascending: orderDirection }) // Apply pagination const from = (page - 1) * postsPerPage const to = from + postsPerPage - 1 query = query.range(from, to) const { data, error, count } = await query if (error) throw error return { posts: data || [], total: count || 0, has_more: (count || 0) > to + 1 } } // Fetch categories for sidebar const { data: categories = [] } = useQuery({ queryKey: ['blog-categories'], queryFn: async () => { const { data, error } = await supabase .from('blog_categories') .select('*') .order('name') if (error) throw error return data } }) // Fetch tags for sidebar const { data: tags = [] } = useQuery({ queryKey: ['blog-tags'], queryFn: async () => { const { data, error } = await supabase .from('blog_tags') .select('*') .order('post_count', { ascending: false }) if (error) throw error return data } }) // Main posts query const { data: postsData, isLoading, error } = useQuery({ queryKey: ['blog-category-posts', type, slug, currentFilters, currentPage], queryFn: () => fetchBlogPosts(currentFilters, currentPage), keepPreviousData: true, enabled: !!(categoryData || tagData) }) const totalPages = Math.ceil((postsData?.total || 0) / postsPerPage) const handleFilterChange = (filters: BlogFilters) => { setCurrentFilters(filters) setCurrentPage(1) } const handlePageChange = (page: number) => { setCurrentPage(page) window.scrollTo({ top: 0, behavior: 'smooth' }) } // Generate pagination const generatePagination = () => { const pages = [] const maxVisible = 7 if (totalPages <= maxVisible) { for (let i = 1; i <= totalPages; i++) { pages.push(i) } } else { pages.push(1) if (currentPage > 3) pages.push('...') const start = Math.max(2, currentPage - 1) const end = Math.min(totalPages - 1, currentPage + 1) for (let i = start; i <= end; i++) { pages.push(i) } if (currentPage < totalPages - 2) pages.push('...') if (totalPages > 1) pages.push(totalPages) } return pages } if (categoryLoading || tagLoading) { return ( <div className="container mx-auto px-4 py-8"> <div className="flex justify-center items-center min-h-[400px]"> <Loader2 className="h-8 w-8 animate-spin text-primary" /> </div> </div> ) } if ((type === 'category' && !categoryData) || (type === 'tag' && !tagData)) { return ( <div className="container mx-auto px-4 py-8"> <div className="text-center"> <h2 className="text-2xl font-bold mb-4"> {type === 'category' ? 'Category' : 'Tag'} not found </h2> <p className="text-muted-foreground mb-6"> The {type === 'category' ? 'category' : 'tag'} you're looking for doesn't exist. </p> <Button asChild> <Link to="/blog">Back to Blog</Link> </Button> </div> </div> ) } const entity = type === 'category' ? categoryData : tagData const title = type === 'category' ? `${entity?.name} Articles - Forex Trading Insights` : `Articles tagged "${entity?.name}" - BrokerAnalysis Blog` const description = type === 'category' ? `All articles about ${entity?.name}. ${entity?.description || 'Explore comprehensive guides and insights on this topic.'}` : `All articles tagged with "${entity?.name}". ${entity?.description || 'Discover related content and insights.'}` return ( <> <BlogSEO title={title} description={description} keywords={type === 'category' ? `${entity?.name}, forex trading, broker reviews` : `${entity?.name}, forex blog, trading insights`} type={type} category={categoryData} tag={tagData} posts={postsData?.posts || []} /> <div className="container mx-auto px-4 py-8"> {/* Header */} <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} className="mb-8" > <Button variant="ghost" asChild className="mb-4"> <Link to="/blog" className="flex items-center gap-2"> <ArrowLeft className="h-4 w-4" /> Back to Blog </Link> </Button> <div className="flex items-center gap-3 mb-4"> {type === 'category' ? ( <div className="flex items-center gap-2"> <div className="w-6 h-6 rounded-full" style={{ backgroundColor: entity?.color || '#3B82F6' }} /> <BookOpen className="h-6 w-6 text-primary" /> </div> ) : ( <Hash className="h-6 w-6 text-primary" /> )} <h1 className="text-3xl md:text-4xl font-bold"> {type === 'category' ? entity?.name : `#${entity?.name}`} </h1> </div> {entity?.description && ( <p className="text-xl text-muted-foreground max-w-3xl"> {entity.description} </p> )} <div className="flex items-center gap-4 mt-4"> <Badge variant="secondary"> {postsData?.total || 0} articles </Badge> {type === 'category' && ( <Badge variant="outline"> Category </Badge> )} {type === 'tag' && ( <Badge variant="outline"> Tag </Badge> )} </div> </motion.div> <div className="grid grid-cols-1 lg:grid-cols-4 gap-8"> {/* Main Content */} <div className="lg:col-span-3"> {/* Filters */} <BlogFilter categories={categories} tags={tags} onFilterChange={handleFilterChange} className="mb-6" /> {/* Blog Posts */} {isLoading ? ( <div className="space-y-6"> {[...Array(3)].map((_, i) => ( <div key={i} className="animate-pulse"> <Card> <CardContent className="p-6"> <div className="h-6 bg-muted rounded mb-4"></div> <div className="h-4 bg-muted rounded mb-2"></div> <div className="h-4 bg-muted rounded w-3/4"></div> </CardContent> </Card> </div> ))} </div> ) : ( <BlogList posts={postsData?.posts || []} /> )} {/* Pagination */} {totalPages > 1 && ( <div className="flex justify-center mt-8"> <div className="flex items-center gap-2"> <Button variant="outline" size="sm" onClick={() => handlePageChange(currentPage - 1)} disabled={currentPage === 1} > Previous </Button> {generatePagination().map((page, index) => ( <div key={index}> {page === '...' ? ( <span className="px-2 py-1">...</span> ) : ( <Button variant={currentPage === page ? 'default' : 'outline'} size="sm" onClick={() => handlePageChange(page as number)} > {page} </Button> )} </div> ))} <Button variant="outline" size="sm" onClick={() => handlePageChange(currentPage + 1)} disabled={currentPage === totalPages} > Next </Button> </div> </div> )} </div> {/* Sidebar */} <div className="lg:col-span-1"> <div className="sticky top-24"> <BlogSidebar categories={categories} tags={tags} onCategorySelect={(categoryId) => { if (type === 'category' && categoryId === categoryData?.id) return window.location.href = `/blog/category/${categories.find(c => c.id === categoryId)?.slug}` }} onTagSelect={(tagId) => { if (type === 'tag' && tagId === tagData?.id) return window.location.href = `/blog/tag/${tags.find(t => t.id === tagId)?.slug}` }} /> </div> </div> </div> </div> </> ) }