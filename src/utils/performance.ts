// Performance optimization utilities for broker templates // Image lazy loading with intersection observer export const createImageLazyLoader = () => { if (typeof window === 'undefined' || !('IntersectionObserver' in window)) { return { observe: () => {}, unobserve: () => {}, disconnect: () => {} } } const imageObserver = new IntersectionObserver((entries) => { entries.forEach((entry) => { if (entry.isIntersecting) { const img = entry.target as HTMLImageElement const src = img.dataset.src if (src) { img.src = src img.classList.remove('lazy') imageObserver.unobserve(img) } } }) }, { rootMargin: '50px 0px', threshold: 0.01 }) return { observe: (element: Element) => imageObserver.observe(element), unobserve: (element: Element) => imageObserver.unobserve(element), disconnect: () => imageObserver.disconnect() } } // Preload critical resources export const preloadCriticalResources = (resources: string[]) => { resources.forEach((resource) => { const link = document.createElement('link') link.rel = 'preload' link.href = resource if (resource.endsWith('.css')) { link.as = 'style' } else if (resource.endsWith('.js')) { link.as = 'script' } else if (resource.match(/\.(jpg|jpeg|png|webp|svg)$/)) { link.as = 'image' } document.head.appendChild(link) }) } // Debounce function for search and filtering export const debounce = <T extends (...args: any[]) => any>( func: T, wait: number ): ((...args: Parameters<T>) => void) => { let timeout: NodeJS.Timeout return (...args: Parameters<T>) => { clearTimeout(timeout) timeout = setTimeout(() => func(...args), wait) } } // Throttle function for scroll events export const throttle = <T extends (...args: any[]) => any>( func: T, limit: number ): ((...args: Parameters<T>) => void) => { let inThrottle: boolean return (...args: Parameters<T>) => { if (!inThrottle) { func(...args) inThrottle = true setTimeout(() => inThrottle = false, limit) } } } // Virtual scrolling for large lists export const calculateVisibleItems = ( scrollTop: number, containerHeight: number, itemHeight: number, totalItems: number, overscan: number = 5 ) => { const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan) const endIndex = Math.min( totalItems - 1, Math.ceil((scrollTop + containerHeight) / itemHeight) + overscan ) return { startIndex, endIndex } } // Memory management for large datasets export const createDataCache = <T>(maxSize: number = 100) => { const cache = new Map<string, T>() return { get: (key: string): T | undefined => cache.get(key), set: (key: string, value: T): void => { if (cache.size >= maxSize) { const firstKey = cache.keys().next().value if (firstKey) { cache.delete(firstKey) } } cache.set(key, value) }, has: (key: string): boolean => cache.has(key), clear: (): void => cache.clear(), size: (): number => cache.size } } // Performance monitoring export const measurePerformance = (name: string, fn: () => void) => { if (typeof window !== 'undefined' && 'performance' in window) { const start = performance.now() fn() const end = performance.now() if (process.env.NODE_ENV === 'development') { console.log(`${name} took ${end - start} milliseconds`) } } else { fn() } } // Image optimization helper export const optimizeImageLoading = (img: HTMLImageElement) => { // Add loading="lazy" for images below the fold if (img.getBoundingClientRect().top > window.innerHeight) { img.loading = 'lazy' } // Add error handling img.onerror = () => { img.src = '/images/placeholder-broker.svg' img.alt = 'Broker logo placeholder' } // Add load event for performance tracking img.onload = () => { img.classList.add('loaded') } } // Core Web Vitals monitoring export const initWebVitals = () => { if (typeof window === 'undefined' || !('PerformanceObserver' in window)) return // Largest Contentful Paint try { const lcpObserver = new PerformanceObserver((list) => { const entries = list.getEntries() const lastEntry = entries[entries.length - 1] if (process.env.NODE_ENV === 'development') { console.log('LCP:', lastEntry.startTime) } }) lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] }) } catch (e) { // Fallback for browsers that don't support LCP } // Cumulative Layout Shift try { let clsValue = 0 const clsObserver = new PerformanceObserver((list) => { for (const entry of list.getEntries()) { if (!(entry as any).hadRecentInput) { clsValue += (entry as any).value } } if (process.env.NODE_ENV === 'development') { console.log('CLS:', clsValue) } }) clsObserver.observe({ entryTypes: ['layout-shift'] }) } catch (e) { // Fallback for browsers that don't support CLS } // First Input Delay try { const fidObserver = new PerformanceObserver((list) => { for (const entry of list.getEntries()) { const fid = (entry as any).processingStart - entry.startTime if (process.env.NODE_ENV === 'development') { console.log('FID:', fid) } } }) fidObserver.observe({ entryTypes: ['first-input'] }) } catch (e) { // Fallback for browsers that don't support FID } } // Resource hints for better loading export const addResourceHints = () => { if (typeof document === 'undefined') return // DNS prefetch for external domains const dnsPrefetchDomains = [ 'fonts.googleapis.com', 'fonts.gstatic.com', 'api.supabase.co' ] dnsPrefetchDomains.forEach(domain => { const link = document.createElement('link') link.rel = 'dns-prefetch' link.href = `//${domain}` document.head.appendChild(link) }) // Preconnect to critical origins const preconnectOrigins = [ 'https://fonts.googleapis.com', 'https://api.supabase.co' ] preconnectOrigins.forEach(origin => { const link = document.createElement('link') link.rel = 'preconnect' link.href = origin link.crossOrigin = 'anonymous' document.head.appendChild(link) }) }