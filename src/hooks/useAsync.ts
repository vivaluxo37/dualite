import { useState, useEffect } from 'react' interface UseAsyncOptions { onError?: (error: Error) => void onSuccess?: (data: any) => void retryCount?: number retryDelay?: number } export function useAsync<T>( asyncFunction: () => Promise<T>, dependencies: any[] = [], options: UseAsyncOptions = {} ) { const { onError, onSuccess, retryCount = 3, retryDelay = 1000 } = options const [data, setData] = useState<T | null>(null) const [loading, setLoading] = useState(true) const [error, setError] = useState<Error | null>(null) const [retryAttempt, setRetryAttempt] = useState(0) const execute = async () => { try { setLoading(true) setError(null) const result = await asyncFunction() setData(result) onSuccess?.(result) } catch (err) { const error = err instanceof Error ? err : new Error('Unknown error occurred') setError(error) onError?.(error) // Auto-retry logic if (retryAttempt < retryCount) { setTimeout(() => { setRetryAttempt(prev => prev + 1) execute() }, retryDelay * (retryAttempt + 1)) } } finally { setLoading(false) } } useEffect(() => { execute() }, dependencies) const refetch = () => { setRetryAttempt(0) execute() } return { data, loading, error, refetch, retryAttempt } } // Hook for handling route-based data loading with error states export function useRouteData<T>( dataGetter: () => T | null, _fallbackMessage: string = "Loading..." ) { const [data, setData] = useState<T | null>(null) const [loading, setLoading] = useState(true) const [error, setError] = useState<Error | null>(null) useEffect(() => { try { setLoading(true) const result = dataGetter() if (result === null || result === undefined) { throw new Error('Data not found') } setData(result) setError(null) } catch (err) { const error = err instanceof Error ? err : new Error('Failed to load data') setError(error) setData(null) } finally { setLoading(false) } }, []) return { data, loading, error, refetch: () => { try { setLoading(true) const result = dataGetter() if (result === null || result === undefined) { throw new Error('Data not found') } setData(result) setError(null) } catch (err) { const error = err instanceof Error ? err : new Error('Failed to load data') setError(error) setData(null) } finally { setLoading(false) } } } } // Debounce utility for preventing excessive API calls export function useDebounce<T>(value: T, delay: number): T { const [debouncedValue, setDebouncedValue] = useState<T>(value) useEffect(() => { const handler = setTimeout(() => { setDebouncedValue(value) }, delay) return () => { clearTimeout(handler) } }, [value, delay]) return debouncedValue } // Hook for handling offline/online status export function useNetworkStatus() { const [isOnline, setIsOnline] = useState(navigator.onLine) useEffect(() => { const handleOnline = () => setIsOnline(true) const handleOffline = () => setIsOnline(false) window.addEventListener('online', handleOnline) window.addEventListener('offline', handleOffline) return () => { window.removeEventListener('online', handleOnline) window.removeEventListener('offline', handleOffline) } }, []) return { isOnline } }