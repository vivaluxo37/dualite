import { WorkflowOrchestrator } from '../src/lib/workflow-orchestrator'; import { readFileSync } from 'fs'; import { join } from 'path'; /** * Workflow execution script * This script executes the complete SEO workflow for configured brokers */ interface ExecutionConfig { supabaseProjectId: string; brokerNames: string[]; contentTypes: ('guide' | 'review' | 'comparison' | 'tutorial' | 'news')[]; qualityThreshold: number; maxConcurrentProcesses: number; enableDeployment: boolean; retryFailedSteps: boolean; notificationSettings: { email?: string; webhook?: string; slack?: string; }; debug?: boolean; logLevel?: 'error' | 'warn' | 'info' | 'debug'; } class WorkflowExecutor { private config: ExecutionConfig; constructor(config: ExecutionConfig) { this.config = config; } async execute(): Promise<void> { console.log('üöÄ Starting SEO Workflow Execution...'); console.log('üìä Configuration:', { brokers: this.config.brokerNames.length, contentTypes: this.config.contentTypes, qualityThreshold: this.config.qualityThreshold, enableDeployment: this.config.enableDeployment }); try { // Initialize workflow orchestrator const orchestrator = new WorkflowOrchestrator(this.config); // Set up progress tracking this.setupProgressTracking(orchestrator); // Execute workflow console.log('‚ö° Executing workflow...'); const results = await orchestrator.executeWorkflow(); // Display results this.displayResults(results); // Save results to file await this.saveResults(results); console.log('‚úÖ Workflow execution completed successfully!'); } catch (error) { console.error('‚ùå Workflow execution failed:', error); await this.handleExecutionError(error); process.exit(1); } } private setupProgressTracking(orchestrator: WorkflowOrchestrator): void { orchestrator.on('progress', (progress) => { const percentage = Math.round((progress.completedSteps / progress.totalSteps) * 100); console.log(`üìà Progress: ${percentage}% (${progress.completedSteps}/${progress.totalSteps})`); console.log(`üîÑ Current Step: ${progress.currentStep}`); console.log(`üìä Step Progress: ${progress.stepProgress}%`); console.log(`üè¢ Brokers Processed: ${progress.brokersProcessed}/${progress.totalBrokers}`); console.log('---'); }); orchestrator.on('error', (error) => { console.error('‚ùå Workflow Error:', error.message); if (this.config.debug) { console.error('Stack:', error.stack); } }); orchestrator.on('log', (log) => { if (this.config.logLevel === 'debug' || (this.config.logLevel === 'info' && log.level !== 'debug') || (this.config.logLevel === 'warn' && ['error', 'warn'].includes(log.level)) || (this.config.logLevel === 'error' && log.level === 'error')) { console.log(`[${log.level.toUpperCase()}] ${log.message}`); if (log.brokerName) { console.log(` Broker: ${log.brokerName}`); } } }); } private displayResults(results: any): void { console.log('\nüìã Workflow Results Summary'); console.log('=========================='); const summary = results.summary; console.log(`üè¢ Brokers Processed: ${summary.totalBrokersProcessed}`); console.log(`üîë Keywords Generated: ${summary.totalKeywordsGenerated}`); console.log(`üìù Content Pieces Generated: ${summary.totalContentPiecesGenerated}`); console.log(`‚ö° Content Pieces Optimized: ${summary.totalContentPiecesOptimized}`); console.log(`üìä Content Pieces Published: ${summary.totalContentPiecesPublished}`); console.log(`üéØ Average Quality Score: ${summary.averageQualityScore}`); console.log(`üîç Average SEO Score: ${summary.averageSEOScore}`); console.log(`‚è±Ô∏è Total Processing Time: ${Math.round(summary.totalProcessingTime / 1000)}s`); console.log(`‚úÖ Success Rate: ${summary.successRate}%`); console.log(`‚ùå Errors Encountered: ${summary.errorsEncountered}`); if (results.errors && results.errors.length > 0) { console.log('\n‚ö†Ô∏è Errors:'); results.errors.forEach((error: any, index: number) => { console.log(`${index + 1}. ${error.step} - ${error.brokerName}: ${error.message}`); }); } } private async saveResults(results: any): Promise<void> { try { const timestamp = new Date().toISOString().replace(/[:.]/g, '-'); const filename = `workflow-results-${timestamp}.json`; const filepath = join(__dirname, '..', 'reports', filename); const reportData = { timestamp: new Date().toISOString(), config: this.config, results: results, environment: { nodeVersion: process.version, platform: process.platform, arch: process.arch } }; // In a real implementation, this would write to file system // For now, we'll just log the intent console.log(`üìÑ Results saved to: ${filepath}`); // Store in database if available try { const { supabase } = await import('../src/lib/supabase'); const { data, error } = await supabase .from('workflow_executions') .insert([reportData]); if (error) { console.warn('‚ö†Ô∏è Failed to store results in database:', error.message); } else { console.log('‚úÖ Results stored in database'); } } catch (dbError) { console.warn('‚ö†Ô∏è Database not available for storing results'); } } catch (error) { console.error('‚ùå Failed to save results:', error); } } private async handleExecutionError(error: any): Promise<void> { console.error('üö® Handling execution error...'); const errorReport = { timestamp: new Date().toISOString(), error: { message: error.message, stack: error.stack, name: error.name }, config: this.config, environment: { nodeVersion: process.version, platform: process.platform, arch: process.arch, cwd: process.cwd() } }; try { // Store error report in database if available const { supabase } = await import('../src/lib/supabase'); const { data, error: dbError } = await supabase .from('workflow_execution_errors') .insert([errorReport]); if (dbError) { console.warn('‚ö†Ô∏è Failed to store error report in database:', dbError.message); } else { console.log('‚úÖ Error report stored in database'); } } catch (dbError) { console.warn('‚ö†Ô∏è Database not available for storing error report'); } // Send notification if configured if (this.config.notificationSettings?.email) { console.log('üìß Error notification would be sent to:', this.config.notificationSettings.email); } } } // Load configuration function loadConfig(): ExecutionConfig { // Try to load from config file try { const configPath = join(__dirname, '..', 'workflow-config.json'); const configData = readFileSync(configPath, 'utf8'); return JSON.parse(configData); } catch (error) { console.log('üìù Using default configuration'); } // Default configuration return { supabaseProjectId: process.env.VITE_SUPABASE_PROJECT_ID || 'your-project-id', brokerNames: ['XM', 'FP Markets', 'Pepperstone'], // Default test brokers contentTypes: ['review', 'guide'], qualityThreshold: 70, maxConcurrentProcesses: 3, enableDeployment: process.env.ENABLE_DEPLOYMENT === 'true', retryFailedSteps: true, notificationSettings: { email: process.env.NOTIFICATION_EMAIL, webhook: process.env.WEBHOOK_URL, slack: process.env.SLACK_WEBHOOK }, debug: process.env.DEBUG === 'true', logLevel: (process.env.LOG_LEVEL as any) || 'info' }; } // Command line argument parsing function parseArgs(): { configPath?: string; brokers?: string; types?: string; help: boolean } { const args = process.argv.slice(2); const parsed: any = { help: false }; for (let i = 0; i < args.length; i++) { const arg = args[i]; if (arg === '--help' || arg === '-h') { parsed.help = true; } else if (arg === '--config' || arg === '-c') { parsed.configPath = args[i + 1]; i++; } else if (arg === '--brokers' || arg === '-b') { parsed.brokers = args[i + 1]; i++; } else if (arg === '--types' || arg === '-t') { parsed.types = args[i + 1]; i++; } } return parsed; } // Display help function displayHelp(): void { console.log(` SEO Workflow Execution Script Usage: npx ts-node scripts/execute-workflow.ts [options] Options: -h, --help Show this help message -c, --config <path> Path to configuration file -b, --brokers <names> Comma-separated list of broker names -t, --types <types> Comma-separated list of content types (review,guide,comparison,tutorial,news) Environment Variables: VITE_SUPABASE_PROJECT_ID Supabase project ID VITE_SUPABASE_URL Supabase URL VITE_SUPABASE_ANON_KEY Supabase anonymous key ENABLE_DEPLOYMENT Enable deployment (true/false) NOTIFICATION_EMAIL Email for notifications WEBHOOK_URL Webhook URL for notifications SLACK_WEBHOOK Slack webhook for notifications DEBUG Enable debug logging (true/false) LOG_LEVEL Log level (error,warn,info,debug) Examples: npx ts-node scripts/execute-workflow.ts npx ts-node scripts/execute-workflow.ts --brokers "XM,FP Markets" --types "review,guide" npx ts-node scripts/execute-workflow.ts --config workflow-config.json `); } // Main execution function async function main(): Promise<void> { const args = parseArgs(); if (args.help) { displayHelp(); return; } try { let config = loadConfig(); // Override config with command line arguments if (args.brokers) { config.brokerNames = args.brokers.split(',').map((b: string) => b.trim()); } if (args.types) { config.contentTypes = args.types.split(',').map((t: string) => t.trim() as any); } const executor = new WorkflowExecutor(config); await executor.execute(); } catch (error) { console.error('‚ùå Fatal error:', error); process.exit(1); } } // Export for use in other modules export { WorkflowExecutor, ExecutionConfig, loadConfig }; // Run if this is the main module if (require.main === module) { main().catch(console.error); }