import { contentDistributionWorkflow } from '../src/lib/content-distribution-workflow'; import { supabase } from '../src/lib/supabase'; /** * Execute Comprehensive Content Distribution Strategy * * This script implements a complete content distribution and promotion system * that automatically distributes content across multiple channels, tracks performance, * and optimizes campaigns in real-time. */ class ContentDistributionExecutor { constructor() { this.workflow = contentDistributionWorkflow; } async executeDistributionStrategy() { console.log('🚀 Starting comprehensive content distribution strategy execution...\n'); try { // Execute the complete distribution workflow const results = await this.workflow.executeComprehensiveDistributionWorkflow(); // Display comprehensive results this.displayResults(results); // Save execution summary await this.saveExecutionSummary(results); // Generate recommendations const recommendations = this.generateRecommendations(results); console.log('\n📋 Recommendations:'); recommendations.forEach((rec, index) => { console.log(`${index + 1}. ${rec}`); }); console.log('\n✅ Content distribution strategy execution completed successfully!'); return results; } catch (error) { console.error('❌ Error executing content distribution strategy:', error); throw error; } } async startContinuousDistribution() { console.log('🔄 Starting continuous content distribution system...\n'); try { await this.workflow.startContinuousDistribution(); console.log('✅ Continuous distribution system started successfully!'); console.log('📊 The system will now automatically:'); console.log(' • Distribute new content across all channels'); console.log(' • Monitor performance metrics'); console.log(' • Optimize campaigns based on data'); console.log(' • Generate performance reports'); console.log('\n💡 Use getStatus() to check system status'); } catch (error) { console.error('❌ Error starting continuous distribution:', error); throw error; } } async stopContinuousDistribution() { console.log('⏹️ Stopping continuous content distribution system...\n'); try { await this.workflow.stopContinuousDistribution(); console.log('✅ Continuous distribution system stopped successfully!'); } catch (error) { console.error('❌ Error stopping continuous distribution:', error); throw error; } } async getDistributionStatus() { console.log('📊 Checking content distribution system status...\n'); try { const status = await this.workflow.getDistributionStatus(); console.log('📈 Distribution System Status:'); console.log(` Running: ${status.is_running ? '✅ Yes' : '❌ No'}`); console.log(` Last Execution: ${status.last_execution || 'Never'}`); console.log(` Active Campaigns: ${status.active_campaigns}`); console.log('\n📅 Upcoming Schedule:'); status.upcoming_schedule.forEach(schedule => { console.log(` • ${schedule.time}: ${schedule.tasks}`); }); return status; } catch (error) { console.error('❌ Error getting distribution status:', error); throw error; } } async createDistributionStrategy(contentId, contentType) { console.log(`📝 Creating distribution strategy for content: ${contentId}\n`); try { // Get content data from database const contentData = await this.getContentData(contentId, contentType); if (!contentData) { throw new Error(`Content not found: ${contentId}`); } // Create distribution strategy using the service const distributionService = this.workflow['distributionService']; const strategy = await distributionService.createDistributionStrategy(contentId, contentData); console.log('✅ Distribution strategy created successfully!'); console.log(`📋 Strategy ID: ${strategy.id}`); console.log(`🎯 Target Channels: ${strategy.promotion_channels.length}`); console.log(`📊 Budget Allocation: $${strategy.budget_allocation?.total_budget || 0}`); console.log(`⏰ Timeline: ${strategy.distribution_timeline.immediate.length} immediate actions`); return strategy; } catch (error) { console.error('❌ Error creating distribution strategy:', error); throw error; } } async executeSpecificStrategy(strategyId) { console.log(`🚀 Executing specific distribution strategy: ${strategyId}\n`); try { // Get strategy from database const strategy = await this.getStrategyFromDatabase(strategyId); if (!strategy) { throw new Error(`Strategy not found: ${strategyId}`); } // Execute the strategy const distributionService = this.workflow['distributionService']; const result = await distributionService.executeDistributionStrategy(strategy); console.log('✅ Strategy executed successfully!'); console.log(`📊 Execution Summary:`); console.log(` • Immediate Distribution: ${Object.keys(result.immediate_distribution || {}).length} channels`); console.log(` • Scheduled Tasks: ${result.scheduled_distribution?.total_scheduled || 0}`); console.log(` • Ongoing Promotions: ${Object.keys(result.ongoing_promotion || {}).length} types`); return result; } catch (error) { console.error('❌ Error executing strategy:', error); throw error; } } async analyzeContentPerformance(contentId, timeframe = '7d') { console.log(`📊 Analyzing performance for content: ${contentId} (${timeframe})\n`); try { const distributionService = this.workflow['distributionService']; const performance = await distributionService.trackContentPerformance(contentId, timeframe); console.log('📈 Performance Analysis Results:'); console.log(` • Total Sessions: ${performance.metrics.engagement_metrics.page_views.toLocaleString()}`); console.log(` • Conversion Rate: ${(performance.metrics.conversion_metrics.conversion_rate * 100).toFixed(2)}%`); console.log(` • ROI: $${performance.roi_analysis.total_returns.toLocaleString()}`); console.log(` • Top Traffic Source: ${this.getTopTrafficSource(performance.metrics.traffic_sources)}`); console.log('\n💡 Key Recommendations:'); performance.recommendations.forEach((rec, index) => { console.log(` ${index + 1}. ${rec.description}`); }); return performance; } catch (error) { console.error('❌ Error analyzing content performance:', error); throw error; } } displayResults(results) { console.log('\n📊 Content Distribution Results Summary:'); console.log('=' .repeat(60)); console.log('\n📈 Key Metrics:'); console.log(` • Total Content Processed: ${results.total_content_processed}`); console.log(` • Strategies Created: ${results.strategies_created}`); console.log(` • Distributions Executed: ${results.distributions_executed}`); console.log(` • Performance Analyses: ${results.performance_analyzed}`); console.log(` • Optimizations Implemented: ${results.optimizations_implemented}`); console.log(` • Errors Encountered: ${results.errors.length}`); if (results.errors.length > 0) { console.log('\n❌ Errors:'); results.errors.forEach((error, index) => { console.log(` ${index + 1}. ${error.step}: ${error.error}`); }); } console.log('\n⚡ Workflow Summary:'); console.log(` • Duration: ${results.summary.workflow_duration}`); console.log(` • Success Rate: ${results.summary.success_rate}`); console.log('\n🎯 Top Performing Channels:'); results.summary.top_performing_channels.forEach((channel, index) => { console.log(` ${index + 1}. ${channel}`); }); console.log('\n💡 Key Insights:'); results.summary.key_insights.forEach((insight, index) => { console.log(` ${index + 1}. ${insight}`); }); console.log('\n📋 Next Steps:'); results.summary.next_steps.forEach((step, index) => { console.log(` ${index + 1}. ${step}`); }); } async saveExecutionSummary(results) { try { await supabase.from('workflow_executions').insert([{ workflow_type: 'content_distribution', execution_data: results, summary: results.summary, executed_at: new Date().toISOString() }]); console.log('💾 Execution summary saved to database'); } catch (error) { console.warn('⚠️ Could not save execution summary to database:', error.message); } } generateRecommendations(results) { const recommendations = []; if (results.distributions_executed > 0) { recommendations.push('Continue with automated distribution workflows'); recommendations.push('Monitor high-performing content for scaling opportunities'); } if (results.optimizations_implemented > 0) { recommendations.push('Review optimization effectiveness after 7 days'); } if (results.errors.length > 0) { recommendations.push('Investigate and resolve error sources'); } recommendations.push('Schedule weekly performance reviews'); recommendations.push('Expand distribution channels based on performance data'); return recommendations; } async getContentData(contentId, contentType) { let tableName; switch (contentType) { case 'blog_post': tableName = 'blog_posts'; break; case 'broker_review': tableName = 'broker_reviews'; break; case 'comparison_page': tableName = 'comparison_pages'; break; case 'educational_content': tableName = 'educational_content'; break; default: throw new Error(`Unknown content type: ${contentType}`); } const { data, error } = await supabase .from(tableName) .select('*') .eq('id', contentId) .single(); if (error) throw error; return data; } async getStrategyFromDatabase(strategyId) { const { data, error } = await supabase .from('content_distribution_strategies') .select('*') .eq('id', strategyId) .single(); if (error) throw error; return data?.strategy_data; } getTopTrafficSource(trafficSources) { let maxSessions = 0; let topSource = ''; Object.entries(trafficSources).forEach(([source, data]) => { if (data.sessions > maxSessions) { maxSessions = data.sessions; topSource = source; } }); return topSource.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase()); } } // Command line interface async function main() { const executor = new ContentDistributionExecutor(); const args = process.argv.slice(2); const command = args[0]; try { switch (command) { case 'execute': await executor.executeDistributionStrategy(); break; case 'start': await executor.startContinuousDistribution(); break; case 'stop': await executor.stopContinuousDistribution(); break; case 'status': await executor.getDistributionStatus(); break; case 'create-strategy': if (!args[1] || !args[2]) { console.log('Usage: node execute-content-distribution.js create-strategy <contentId> <contentType>'); process.exit(1); } await executor.createDistributionStrategy(args[1], args[2]); break; case 'execute-strategy': if (!args[1]) { console.log('Usage: node execute-content-distribution.js execute-strategy <strategyId>'); process.exit(1); } await executor.executeSpecificStrategy(args[1]); break; case 'analyze': if (!args[1]) { console.log('Usage: node execute-content-distribution.js analyze <contentId> [timeframe]'); process.exit(1); } await executor.analyzeContentPerformance(args[1], args[2] || '7d'); break; default: console.log('Content Distribution Strategy Executor'); console.log(''); console.log('Commands:'); console.log(' execute Execute comprehensive distribution workflow'); console.log(' start Start continuous distribution system'); console.log(' stop Stop continuous distribution system'); console.log(' status Check system status'); console.log(' create-strategy Create distribution strategy for specific content'); console.log(' execute-strategy Execute specific distribution strategy'); console.log(' analyze Analyze content performance'); console.log(''); console.log('Examples:'); console.log(' node execute-content-distribution.js execute'); console.log(' node execute-content-distribution.js start'); console.log(' node execute-content-distribution.js create-strategy blog_123 blog_post'); console.log(' node execute-content-distribution.js analyze content_456 30d'); break; } } catch (error) { console.error('Execution failed:', error.message); process.exit(1); } } // Export for use as module export { ContentDistributionExecutor }; // Run if called directly if (require.main === module) { main().catch(console.error); }