#!/usr/bin/env tsx import fs from 'fs' import path from 'path' interface ScanResult { type: '404' | 'theme' | 'routing' | 'data' severity: 'critical' | 'high' | 'medium' | 'low' file: string line?: number message: string details?: any } interface ComponentAnalysis { file: string imports: string[] routingIssues: string[] themeIssues: string[] dataIssues: string[] externalLinks: string[] } class ForexBrokersScanner { private results: ScanResult[] = [] private projectRoot: string constructor() { this.projectRoot = path.resolve(__dirname, '..') } private async findFiles(pattern: string): Promise<string[]> { const files: string[] = [] const searchDir = path.join(this.projectRoot, pattern.replace(/\*\*\/?/, '').split('/')[0]) if (fs.existsSync(searchDir)) { this.scanDirectory(searchDir, pattern, files) } return files } private scanDirectory(dir: string, pattern: string, files: string[]) { const entries = fs.readdirSync(dir, { withFileTypes: true }) for (const entry of entries) { const fullPath = path.join(dir, entry.name) const relativePath = path.relative(this.projectRoot, fullPath) if (entry.isDirectory()) { this.scanDirectory(fullPath, pattern, files) } else if (this.matchesPattern(relativePath, pattern)) { files.push(relativePath) } } } private matchesPattern(filePath: string, pattern: string): boolean { const regexPattern = pattern .replace(/\*\*/g, '.*') .replace(/\*/g, '[^/]*') .replace(/\?/g, '.') const regex = new RegExp(`^${regexPattern}$`) return regex.test(filePath) } async runComprehensiveScan(): Promise<ScanResult[]> { console.log('ðŸ” Starting comprehensive forex-brokers scan...') // Phase 1: Analyze routing and component structure await this.analyzeRouting() // Phase 2: Scan data files await this.scanDataFiles() // Phase 3: Check theme compatibility await this.analyzeThemeCompatibility() // Phase 4: Validate external links await this.validateExternalLinks() return this.results } private async analyzeRouting() { console.log('ðŸ“‹ Analyzing routing structure...') // Read main router file const routerPath = path.join(this.projectRoot, 'src/pages/forex-brokers/ForexBrokersRouter.tsx') const routerContent = fs.readFileSync(routerPath, 'utf-8') // Check for missing imports in lazy loading const lazyImportPattern = /lazy\(\(\) => import\(['"]([^'"]+)['"]\)\)/g let match while ((match = lazyImportPattern.exec(routerContent)) !== null) { const importPath = match[1] const fullPath = path.join(this.projectRoot, 'src', importPath) if (!fs.existsSync(fullPath)) { this.results.push({ type: '404', severity: 'critical', file: routerPath, message: `Missing lazy-loaded component: ${importPath}`, details: { importPath, fullPath } }) } } // Analyze URL mappings const urlMappingsPattern = /const urlMappings: Record<string, string> = \{([^}]+)\}/s const mappingsMatch = routerContent.match(urlMappingsPattern) if (mappingsMatch) { const mappingsContent = mappingsMatch[1] const mappingPattern = /['"]([^'"]+)['"]:\s*['"]([^'"]+)['"]/g while ((match = mappingPattern.exec(mappingsContent)) !== null) { const [_, url, key] = match // Validate mapping consistency if (!url.includes('forex-brokers')) { this.results.push({ type: 'routing', severity: 'medium', file: routerPath, message: `URL mapping may be malformed: ${url} -> ${key}`, details: { url, key } }) } } } } private async scanDataFiles() { console.log('ðŸ“Š Scanning data files...') // Check region data files const regionDataDir = path.join(this.projectRoot, 'src/data/forex-brokers/regions') const regionFiles = fs.readdirSync(regionDataDir).filter(f => f.endsWith('.ts') && f !== 'index.ts' && f !== 'types.ts') for (const file of regionFiles) { const filePath = path.join(regionDataDir, file) const content = fs.readFileSync(filePath, 'utf-8') this.analyzeDataFile(filePath, content, 'region') } // Check trading type data files const tradingTypesDir = path.join(this.projectRoot, 'src/data/forex-brokers/trading-types') const tradingTypeFiles = fs.readdirSync(tradingTypesDir).filter(f => f.endsWith('.ts') && f !== 'index.ts' && f !== 'types.ts') for (const file of tradingTypeFiles) { const filePath = path.join(tradingTypesDir, file) const content = fs.readFileSync(filePath, 'utf-8') this.analyzeDataFile(filePath, content, 'trading-type') } } private analyzeDataFile(filePath: string, content: string, type: string) { // Check for basic structure if (!content.includes('id:')) { this.results.push({ type: 'data', severity: 'critical', file: filePath, message: `Missing required 'id' field in ${type} data file` }) } if (!content.includes('brokers:')) { this.results.push({ type: 'data', severity: 'high', file: filePath, message: `Missing 'brokers' array in ${type} data file` }) } // Check broker website URLs const urlPattern = /websiteUrl:\s*['"]([^'"]+)['"]/g let match while ((match = urlPattern.exec(content)) !== null) { const url = match[1] if (!url.startsWith('http')) { this.results.push({ type: 'data', severity: 'medium', file: filePath, message: `Invalid website URL format: ${url}`, details: { url } }) } } // Check for missing required fields in brokers const brokerPattern = /\{\s*id:\s*['"]([^'"]+)['"][^}]*\}/gs while ((match = brokerPattern.exec(content)) !== null) { const brokerBlock = match[0] const brokerId = match[1] const requiredFields = ['name', 'logo', 'rating', 'regulation', 'minDeposit', 'spread', 'leverage', 'platforms'] for (const field of requiredFields) { if (!brokerBlock.includes(`${field}:`)) { this.results.push({ type: 'data', severity: 'high', file: filePath, message: `Broker '${brokerId}' missing required field: ${field}` }) } } } } private async analyzeThemeCompatibility() { console.log('ðŸŽ¨ Analyzing theme compatibility...') // Scan all page components const pageFiles = await this.findFiles('src/pages/forex-brokers/**/*.tsx') for (const file of pageFiles) { const filePath = path.join(this.projectRoot, file) const content = fs.readFileSync(filePath, 'utf-8') this.analyzeThemeIssues(filePath, content) } } private analyzeThemeIssues(filePath: string, content: string) { // Check for hardcoded colors const hardcodedColorPatterns = [ /#[0-9a-fA-F]{6}/g, // Hex colors /rgb\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)/gi, // RGB colors /bg-\[(#[0-9a-fA-F]{6})\]/g, // Tailwind arbitrary colors ] for (const pattern of hardcodedColorPatterns) { let match while ((match = pattern.exec(content)) !== null) { const color = match[0] this.results.push({ type: 'theme', severity: 'medium', file: filePath, message: `Hardcoded color detected: ${color}`, details: { color, line: this.getLineNumber(content, match.index) } }) } } // Check for missing dark mode variants const bgPattern = /bg-(\w+)(?:-\d+)?/g const textPattern = /text-(\w+)(?:-\d+)?/g const borderPattern = /border-(\w+)(?:-\d+)?/g this.checkMissingDarkVariants(content, filePath, bgPattern, 'background') this.checkMissingDarkVariants(content, filePath, textPattern, 'text') this.checkMissingDarkVariants(content, filePath, borderPattern, 'border') } private checkMissingDarkVariants(content: string, filePath: string, pattern: RegExp, type: string) { const matches = content.matchAll(pattern) const usedColors = new Set() for (const match of matches) { const colorClass = match[0] const color = match[1] // Skip certain colors that don't need dark variants if (['transparent', 'current', 'inherit', 'white', 'black', 'gray', 'slate', 'zinc', 'neutral', 'stone'].includes(color)) { continue } usedColors.add(color) // Check if dark variant exists const darkVariant = `}` if (!content.includes(darkVariant)) { this.results.push({ type: 'theme', severity: 'low', file: filePath, message: `Missing dark mode variant for ${type} color: ${colorClass}`, details: { colorClass, suggestedVariant: darkVariant, line: this.getLineNumber(content, match.index) } }) } } } private async validateExternalLinks() { console.log('ðŸ”— Validating external links...') // This is a simplified check - in production, you'd want to actually HTTP check these const pageFiles = await this.findFiles('src/pages/forex-brokers/**/*.tsx') for (const file of pageFiles) { const filePath = path.join(this.projectRoot, file) const content = fs.readFileSync(filePath, 'utf-8') const urlPattern = /https?:\/\/[^\s'")]+/g let match while ((match = urlPattern.exec(content)) !== null) { const url = match[0] // Basic URL validation try { new URL(url) } catch { this.results.push({ type: '404', severity: 'high', file: filePath, message: `Invalid URL format: ${url}`, details: { line: this.getLineNumber(content, match.index) } }) } } } } private getLineNumber(content: string, index: number): number { const lines = content.substring(0, index).split('\n') return lines.length } private generateReport(results: ScanResult[]) { const report = { summary: { total: results.length, critical: results.filter(r => r.severity === 'critical').length, high: results.filter(r => r.severity === 'high').length, medium: results.filter(r => r.severity === 'medium').length, low: results.filter(r => r.severity === 'low').length, byType: { '404': results.filter(r => r.type === '404').length, 'theme': results.filter(r => r.type === 'theme').length, 'routing': results.filter(r => r.type === 'routing').length, 'data': results.filter(r => r.type === 'data').length } }, results: results.sort((a, b) => { const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 } return severityOrder[b.severity] - severityOrder[a.severity] }) } return report } } // Main execution async function main() { const scanner = new ForexBrokersScanner() const results = await scanner.runComprehensiveScan() const report = scanner.generateReport(results) // Output results console.log('\nðŸ“Š SCAN RESULTS:') console.log('='.repeat(50)) console.log(`Total Issues Found: ${report.summary.total}`) console.log(`Critical: ${report.summary.critical}`) console.log(`High: ${report.summary.high}`) console.log(`Medium: ${report.summary.medium}`) console.log(`Low: ${report.summary.low}`) console.log() // Show issues by type console.log('ðŸ“‹ Issues by Type:') Object.entries(report.summary.byType).forEach(([type, count]) => { console.log(`${type}: ${count}`) }) console.log() // Show detailed results if (report.results.length > 0) { console.log('ðŸ” Detailed Issues:') console.log('='.repeat(50)) report.results.forEach((result, index) => { console.log(`${index + 1}. [${result.severity.toUpperCase()}] ${result.type}`) console.log(` File: ${result.file}${result.line ? `:${result.line}` : ''}`) console.log(` Message: ${result.message}`) if (result.details) { console.log(` Details: ${JSON.stringify(result.details, null, 2)}`) } console.log() }) } // Save report to file const reportPath = path.join(__dirname, '..', 'forex-brokers-scan-report.json') fs.writeFileSync(reportPath, JSON.stringify(report, null, 2)) console.log(`ðŸ“„ Detailed report saved to: ${reportPath}`) } main().catch(console.error)